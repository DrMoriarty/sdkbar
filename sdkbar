#!/usr/bin/env node
const fs = require('fs');
const et = require('elementtree');
const path = require('path');
const child_process = require('child_process');
const package_parser = require('./sdkbar_parser').parser;

if (!String.prototype.startswith) {
  Object.defineProperty(String.prototype, 'startswith', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function(searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    }
  });
}

/*******************
 *
 *  Console utilities
 *
 *******************/

const Reset = "\x1b[0m";
const Bright = "\x1b[1m";
const Dim = "\x1b[2m";
const Underscore = "\x1b[4m";
const Blink = "\x1b[5m";
const Reverse = "\x1b[7m";
const Hidden = "\x1b[8m";

const FgBlack = "\x1b[30m";
const FgRed = "\x1b[31m";
const FgGreen = "\x1b[32m";
const FgYellow = "\x1b[33m";
const FgBlue = "\x1b[34m";
const FgMagenta = "\x1b[35m";
const FgCyan = "\x1b[36m";
const FgWhite = "\x1b[37m";

const BgBlack = "\x1b[40m";
const BgRed = "\x1b[41m";
const BgGreen = "\x1b[42m";
const BgYellow = "\x1b[43m";
const BgBlue = "\x1b[44m";
const BgMagenta = "\x1b[45m";
const BgCyan = "\x1b[46m";
const BgWhite = "\x1b[47m";

function debug(str) {
    var args = [Dim];
    for(key in arguments) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.log.apply(console, args);
}

function log(str) {
    var args = [Bright];
    for(key in arguments) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.log.apply(console, args);
}

function warning(str) {
    var args = [FgYellow, 'Warning:'];
    for(key in arguments) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.log.apply(console, args);
}

function error() {
    var args = [FgRed, 'Error:'];
    for(key in arguments) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.error.apply(console, args);
}

/*******************
 *
 *  Config & Project 
 *
 *******************/

var proj = null;
var conf = null;
var project_root = path.resolve("./");
var install_log_list = [];

function install_log(operation, arg) {
    install_log_list.push({'op': operation, 'arg': arg});
}

function help() {
    console.log(`SDKBAR v 0.0.1

Usage: 
sdkbar --list                    List all installed plugins
sdkbar --install <url or path>   Install new plugin
sdkbar --remove <plugin name>    Uninstall the installed plugin
sdkbar --help                    This page
`);
}

while(true) {
    try {
        proj = JSON.parse(fs.readFileSync(project_root+'/.cocos-project.json', 'utf8'));
        break;
    } catch (err) {
        if(project_root.length >= 2) 
            project_root = path.resolve(project_root+'/../');
        else
            break;
    }
}
if(proj == null) {
    error('Cocos project not found!');
    help();
    process.exit(1);
}

try {
    conf = JSON.parse(fs.readFileSync(project_root+'/.sdkbar.json', 'utf8'));
} catch (err) {
    conf = {};
}

function saveConf() {
    fs.writeFileSync(project_root+'/.sdkbar.json', JSON.stringify(conf, null, 4));
}

/*******************
 *
 *  Parsing command line arguments
 *
 *******************/

var args = process.argv.slice(2);
var command = null;
var argument = null;
args.forEach(function (val, index, array) {
    if(/^--/.test(val)) {
        command = val.substring(2);
    } else if(command != null) {
        argument = val;
    } else {
        console.error('Unknown parameter:', val);
        help();
        process.exit(1);
    }
});


/*******************
 *
 *  File utilities
 *
 *******************/

function extension(fname) {
    return fname.slice((fname.lastIndexOf(".") - 1 >>> 0) + 2);
}

var mkdirSync = function (dirpath) {
    try {
        fs.mkdirSync(dirpath);
    } catch(e) {
        if ( e.code != 'EEXIST' ) throw e;
    }
}

var mkdirpSync = function (dirpath) {
    var absolute = false;
    if(dirpath.lastIndexOf(path.sep, 0) === 0)
        absolute = true;
    var parts = dirpath.split(path.sep);
    for( var i = 1; i <= parts.length; i++ ) {
        var pp = path.join.apply(null, parts.slice(0, i));
        if(absolute)
            pp = path.sep + pp;
        mkdirSync( pp );
    }
}

function copyFileSync( source, target ) {
    var targetFile = target;
    //if target is a directory a new file with the same name will be created
    if ( fs.existsSync( target ) ) {
        if ( fs.lstatSync( target ).isDirectory() ) {
            targetFile = path.join( target, path.basename( source ) );
        }
    }
    debug('Copy file', source, target);
    if(fs.existsSync(targetFile))
        warning('File exist', targetFile);
    fs.writeFileSync(targetFile, fs.readFileSync(source));
    if(targetFile.startsWith(project_root)) {
        targetFile = targetFile.substring(project_root.length);
        var separator = "" + path.sep;
        if(targetFile.startsWith(separator)) {
            targetFile = targetFile.substring(separator.length);
        }
    }
    return targetFile;
}

function copyPathSync(source, target) {
    var result = []
    if ( !fs.lstatSync( source ).isDirectory() ) {
        result.push(copyFileSync(source, target));
    } else {
        target = path.join(target, path.basename(source));
        debug('Copy dir', source, target);
        mkdirpSync(target);
        var files = fs.readdirSync(source);
        for(file of files) {
            var ss = path.join(source,file)
            var stats = fs.lstatSync(ss);
            if (stats.isDirectory()) {
                result = result.concat(copyPathSync(ss, target));
            } else {
                result.push(copyFileSync(ss, target));
            }
        }
    }
    return result;
}

/*
function lookup(dirpath, dir, process_patch, process_file, iterateLevel) {
    iterateLevel = iterateLevel || 0;
    var files = fs.readdirSync(dirpath+dir);
    for(file of files) {
        var fname = path.join(dir,file);
        var stats = fs.lstatSync(dirpath+fname);
        if(path.extname(file) == '.patch' && process_patch) {
            process_patch(fname);
        } else if (stats.isDirectory()) {
            lookup(dirpath, fname, process_patch, process_file, iterateLevel + 1);
        } else if (process_file) {
            process_file(fname);
        }
    }
}
*/

function removeEmptyDirs(dir) {
    while (true) {
        try {
            fs.rmdirSync(dir);
            dir = path.dirname(dir);
        } catch (err) {
            return;
        }
    }
}

/*******************
 *
 *  XML utilities
 *
 *******************/

function xml_append(fname, parent, tag, key, xml) {
    var data = fs.readFileSync(fname).toString();
    var etree = et.parse(data);
    // check if tag already exist
    var xpath = parent+'/'+tag;
    if(key !== null && typeof key !== 'undefined') 
        xpath = xpath + '[@'+key+']';
    var existed = etree.find(xpath);
    if(existed !== null && typeof existed !== 'undefined') {
        warning('Tag already exist:', et.tostring(existed, {'xml_declaration': false, 'indent': true}));
    } else {
        var parent = etree.find(parent);
        var node = et.parse(xml);
        parent.append(node._root);
        //console.log(et.tostring(parent, {'xml_declaration': false, 'indent': true}));
        debug('Append XML tag:', et.tostring(node._root, {'xml_declaration': false, 'indent': true}));
    }
    var xml = etree.write({'xml_declaration': true, 'indent': true, 'encoding': 'UTF-8'});
    fs.writeFileSync(fname, xml);
    return xpath;
}

function xml_remove(fname, parent, xpath) {
    var data = fs.readFileSync(fname).toString();
    var etree = et.parse(data);
    var parent = etree.find(parent);
    var nodes = etree.findall(xpath);
    if(nodes.length > 0) {
        for(key in nodes) {
            var node = nodes[key];
            var ind = parent.getchildren().indexOf(node);
            if(ind >= 0)
                parent.delItem(ind);
            else
                warning('Xml element not found:', xpath);
        }
    } else {
        warning('Xml elements not found:', xpath);
    }
    var xml = etree.write({'xml_declaration': true, 'indent': true, 'encoding': 'UTF-8'});
    fs.writeFileSync(fname, xml);
}

/*******************
 *
 *  Sdkbar functions
 *
 *******************/

function list() {
    console.log('Installed plugins:');
    Object.keys(conf).forEach(function(val, index, array) {
        console.log(val, conf[val].version);
    });
    console.log('');
}

var functioner = {
    /************** SDKBOX methods **************/
    config_merge: function(arg1, arg2) {
        warning('Warning: config_merge is unimplemented yet!');
    },
    copy_files: function(files, from, to) {
        debug('Copy files', files, from, to);
        for(key in files) {
            var src = path.join(from,files[key]);
            var dst = path.join(to,path.basename(files[key]));
            var dst_dir = path.dirname(dst);
            try {
                var copied = copyPathSync(src, to);
                install_log('copy', copied);
            } catch (err) {
                error('Failed copy', src, 'to', dst);
                error(err);
            }
        }
    },
    apply_patch: function(arg1, arg2, arg3) {
        warning('Warning: apply_patch is unimplemented yet!');
    },
    xcode_add_frameworks: function(frameworks) {
        warning('Warning: xcode_add_frameworks is unimplemented yet!');
    },
    xcode_add_sources: function() {
        warning('Warning: xcode_add_sources is unimplemented yet!');
    },
    android_copy_jars: function() {
        warning('Warning: android_copy_jars is unimplemented yet!');
    },
    android_copy_libs: function() {
        warning('Warning: android_copy_libs is unimplemented yet!');
    },
    android_add_sources: function() {
        warning('Warning: android_add_sources unimplemented yet!');
    },
    android_set_permissions: function() {
        warning('Warning: android_set_permissions unimplemented yet!');
    },
    android_add_static_libraries: function() {
        warning('Warning: android_add_static_libraries unimplemented yet!');
    },
    android_add_calls: function() {
        warning('Warning: android_add_calls unimplemented yet!');
    },
    android_add_xml_item: function(obj) {
        var xpath = obj['path'],
            tag = obj['tag'],
            key = obj['key'],
            xml = obj['xml'];
        var file = path.join(project_root, 'frameworks/runtime-src/proj.android-studio/app/AndroidManifest.xml');
        var child = xml_append(file, xpath, tag, 'android:name=\''+key+'\'', xml);
        install_log('xml', {'file': 'frameworks/runtime-src/proj.android-studio/app/AndroidManifest.xml', 'parent': xpath, 'xpath': child});
    },
    satisfies_cocos_version: function() {
        warning('Warning: satisfies_cocos_version unimplemented yet!');
        return false;
    },
    define: function(key, value) {
        warning('Warning: define unimplemented yet!');
    },
    open_documentation: function() {
        warning('Warning: open_documentation unimplemented yet!');
    },
    puts: function() {
        warning('Warning: puts unimplemented yet!');
    },
    
    /************** SdkBar methods **************/
    appDelegateInject: function(params) {
        var fname = path.join(project_root, 'frameworks/runtime-src/Classes/AppDelegate.cpp');
        var data = fs.readFileSync(fname).toString();
        var marker = params['marker'];
        var startMarker = '//BEGIN_'+marker+'\n';
        var endMarker = '//END_'+marker+'\n';
        if('ios' in params) {
            var include = params['ios']['include'];
            var func = params['ios']['function'];
            include = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)\n#include "'+include+'"\n#endif\n';
            func = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)\n    sc->addRegisterCallback('+func+');\n#endif\n';
        }
        if('android' in params) {
            var include = params['android']['include'];
            var func = params['android']['function'];
            include = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)\n#include "'+include+'"\n#endif\n';
            func = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)\n    sc->addRegisterCallback('+func+');\n#endif\n';
        }
        fs.writeFileSync(fname, data);
        install_log('inject', {'file': 'frameworks/runtime-src/Classes/AppDelegate.cpp', 're': '\/\/BEGIN_'+marker+'[\s\S]*\/\/END_'+marker});
    }
};

function script_install(plugin_path, plugin, origin, script) {
    var prev = conf[plugin.name];
    if(typeof prev != 'undefined' && prev != null) {
        error('Plugin', plugin.name, 'already installed (version ', plugin.version+')');
        error('Remove it first');
        process.exit(1);
    }
    conf[plugin.name] = {
        'name': plugin.name,
        'version': plugin.version,
        'origin': origin
    };

    var default_scope = {
        'print': console.log,
        'True': true,
        'False': false,
        'COCOS_PROJECT_TYPE': 'js',
        'COCOS_2DX_VERSION': '3',
        'SDKBOX_PACKAGE_NAME': plugin.name,
        'PLUGIN_PATH': plugin_path,
        'COCOS_RESOURCES_DIR': project_root+'/res/',
        'COCOS_CLASSES_DIR': project_root+'/frameworks/runtime-src/Classes/',
        'ANDROID_ACTIVITY_NAME': 'AppActivity',
        'ANDROID_MK_USES_WILDCARDS': false,
        'ANDROID_ACTIVITY_PATH': project_root+'/frameworks/runtime-src/proj.android-studio/app/src/org/cocos2dx/javascript/',
        'ANDROID_COCOS_SRC_DIR': project_root+'/frameworks/cocos2d-x/cocos/platform/android/java/src/org/cocos2dx/lib/',
        'ANDROID_COCOS_PACKAGE_ROOT': project_root+'/frameworks/cocos2d-x/cocos/platform/android/java/',
        'ANDROID_STUDIO_PROJECT_DIR': project_root+'/frameworks/runtime-src/proj.android-studio/',
        'ANDROID_PROJECT_DIR': project_root+'/frameworks/runtime-src/proj.android/',
        'IOS_PROJECT_DIR': project_root+'/frameworks/runtime-src/proj.ios_mac/',
        'sdkbar': functioner,
        'sdkbox': functioner
    }
    var operators = {
        'IF': function(cond, block1, block2) {
            debug('if', cond);
            var res = this.do_command(cond);
            if(res === true) {
                this.do_block(block1);
            } else if(typeof block2 !== 'undefined' && block2 !== null) {
                this.do_block(block2);
            }
        },
        'AND': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 && arg2;
        },
        'OR': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            debug('or', arg1, arg2);
            return arg1 || arg2;
        },
        'EQ': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 === arg2;
        },
        'NE': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 !== arg2;
        },
        'ADD': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 + arg2;
        },
        'SUB': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 - arg2;
        },
        'MUL': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 * arg2;
        },
        'DIV': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 / arg2;
        },
        'ASSIGN': function(arg1, arg2) {
            arg2 = this.do_command(arg2);
            debug(arg1, '=', arg2);
            default_scope[arg1] = arg2;
            return arg1;
        }
    }

    var str_re1 = /^\'([^\']*)\'$/;
    var str_re2 = /^\"([^\"]*)\"$/;
    var str_re3 = /^\'\'\'([^\']+)\'\'\'$/;
    var int_re = /[0-9]+/;
    var sub_token = /^([^\.]+)\./;
    var yy = {
        result: [],
        indent: [],
        scope: default_scope,
        resolve_name_in_scope: function(n, scope) {
            var prototype=Object.getPrototypeOf(scope);
            if(prototype != null && prototype[n] != null) {
                return prototype[n].bind(scope);
            } else if(n in scope) {
                return scope[n];
            } else if(sub_token.test(n)) {
                var match = n.match(sub_token);
                var tt = match[1];
                var vv = this.resolve_name_in_scope(tt, scope);
                if(vv != null) {
                    // generic object
                    var st2 = n.substring(tt.length+1);
                    return this.resolve_name_in_scope(st2, vv);
                }
            }
            return null;
        },
        resolve_name: function(n) {
            if(str_re3.test(n)) {
                // multiline string
                var match = n.match(str_re3);
                return match[1];
            } else if(str_re1.test(n)) {
                // string
                var match = n.match(str_re1);
                return match[1];
            } else if(str_re2.test(n)) {
                // string
                var match = n.match(str_re2);
                return match[1];
            } else if(int_re.test(n)) {
                // integer
                return parseInt(n);
            } else if(n instanceof Array) {
                // resolve array elements
                var result = [];
                for(k in n) {
                    result.push(this.resolve_name(n[k]));
                }
                return result;
            } else if(n !== null && typeof n === 'object') {
                // object (dictionary)
                var result = {};
                for(k in n) {
                    result[k] = this.resolve_name(n[k]);
                }
                return result;
            } else {
                var res = this.resolve_name_in_scope(n, this.scope);
                if(res == null) {
                    error('variable is undefined', n);
                    return n;
                } else {
                    return res;
                }
            }
        },
        ast: function(ast) {
            yy.result = ast;
        },
        do_block: function(block) {
            var result = null;
            for(key in block) {
                var command = block[key];
                result = this.do_command(command);
            }
            return result;
        },
        do_command: function(command) {
            if(command instanceof Array) {
                // function with args
                var cmd = command.shift();
                var args = command;
                var need_resolve = false;
                var fn = this.resolve_name_in_scope(cmd, operators);
                if(fn == null) {
                    fn = this.resolve_name(cmd);
                    need_resolve = true;
                }
                if(typeof fn === "function" || Object.prototype.toString.call(fn) == '[object Function]') {
                    if(need_resolve) {
                        var processed_args = []
                        for(key in args) {
                            processed_args.push(this.resolve_name(args[key]));
                        }
                        args = processed_args;
                    }
                    var result = fn.apply(this, args);
                    return result;
                } else {
                    error('function', fn, 'is undefined');
                    return null;
                }
            } else {
                // variable or value
                return this.resolve_name(command);
            }
        }
    }
    package_parser.yy = yy;
    package_parser.parse(script);
    var ast = yy.result;
    debug('Get config AST:', JSON.stringify(ast));
    yy.do_block(ast);
    conf[plugin.name]['install_log'] = install_log_list;
}

function install(path) {
    if(/^http/.test(path)) {
        // TODO remote install
    } else {
        // local install
        var plugin = null;
        var install_script = null;
        try {
            if(fs.existsSync(path+'/package.json') && fs.existsSync(path+'/sdkbar.package')) {
                plugin = JSON.parse(fs.readFileSync(path+'/package.json', 'utf8'));
                install_script = fs.readFileSync(path+'/sdkbar.package', 'utf8');
                console.log('Installing', plugin.name, 'version', plugin.version, 'from', path);
                script_install(path, plugin, path, install_script);
            } else {
                install_script = fs.readFileSync(path+'/sdkbox.package', 'utf8');
                console.log('Installing SDKBOX plugin from', path);
                script_install(path, {'name': 'generic-sdkbox-plugin'}, path, install_script);
            }
        } catch (err) {
            if(err["code"] === "ENOENT") {
                // no such file
                error(err);
                process.exit(1);
            } else {
                if(typeof err['message'] !== 'undefined')
                    error(err['message'])
                else
                    error(err);
                process.exit(1);
            }
        }
    }
}

function remove(name) {
    var cc = conf[name];
    if(typeof cc == 'undefined' || cc == null) {
        console.error('Plugin', name, 'not found!');
        process.exit(1);
    }
    var origin = cc.origin;
    var log = cc['install_log'];
    if(typeof log != 'undefined' && log != null) {
        for(key in log) {
            var op = log[key];
            if(op['op'] === 'copy') {
                // undo copy file
                var args = op['arg'];
                for(args_key in args) {
                    var arg = args[args_key];
                    if(!arg.startsWith(path.sep))
                        arg = path.join(project_root, arg);
                    if(fs.existsSync(arg)) {
                        fs.unlinkSync(arg);
                    } else {
                        warning('Warning: file not found', arg);
                    }
                    removeEmptyDirs(path.dirname(arg));
                }
            } else if(op['op'] === 'xml') {
                var arg = op['arg'];
                var file = arg['file'];
                var parent = arg['parent'];
                var xpath = arg['xpath'];
                if(!file.startsWith(path.sep))
                    file = path.join(project_root, file);
                xml_remove(file, parent, xpath);
            } else {
                error('Unknown install operation:', op['op'], 'with arg:', op['arg']);
            }
        }
    }
    delete conf[name];
}

if(command === 'help') {
    help();
} else if(command === 'list') {
    list();
} else if(command === 'install') {
    argument = path.resolve(argument);
    install(argument);
    saveConf();
} else if(command === 'remove') {
    remove(argument);
    saveConf();
} else if(command != null) {
    error('Wrong command:', command);
    help();
    process.exit(1);
} else {
    error('No command!');
    help();
    process.exit(1);
}
