#!/usr/bin/env node
const fs = require('fs');
const et = require('elementtree');
const path = require('path');
const child_process = require('child_process');
const package_parser = require('./sdkbar_parser').parser;
const url = require('url');
const Q = require('q');
const unzip = require('unzip');
const nodegit = require('nodegit');
const sync = require('sync');

if (!String.prototype.startswith) {
  Object.defineProperty(String.prototype, 'startswith', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function(searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    }
  });
}

/*******************
 *
 *  Console utilities
 *
 *******************/

const Reset = "\x1b[0m";
const Bright = "\x1b[1m";
const Dim = "\x1b[2m";
const Underscore = "\x1b[4m";
const Blink = "\x1b[5m";
const Reverse = "\x1b[7m";
const Hidden = "\x1b[8m";

const FgBlack = "\x1b[30m";
const FgRed = "\x1b[31m";
const FgGreen = "\x1b[32m";
const FgYellow = "\x1b[33m";
const FgBlue = "\x1b[34m";
const FgMagenta = "\x1b[35m";
const FgCyan = "\x1b[36m";
const FgWhite = "\x1b[37m";

const BgBlack = "\x1b[40m";
const BgRed = "\x1b[41m";
const BgGreen = "\x1b[42m";
const BgYellow = "\x1b[43m";
const BgBlue = "\x1b[44m";
const BgMagenta = "\x1b[45m";
const BgCyan = "\x1b[46m";
const BgWhite = "\x1b[47m";

function debug(str) {
    var args = [Dim];
    for(key in arguments) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.log.apply(console, args);
}

function log(str) {
    var args = [Bright];
    for(key in arguments) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.log.apply(console, args);
}

function warning(str) {
    var args = [FgYellow, 'Warning:'];
    for(key in arguments) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.log.apply(console, args);
}

function error() {
    var args = [FgRed, 'Error:'];
    for(key in arguments) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.error.apply(console, args);
}

/*******************
 *
 *  Config & Project 
 *
 *******************/

var proj = null;
var conf = null;
var project_root = path.resolve("./");
var install_log_list = [];
var variables = {};

function install_log(operation, arg) {
    install_log_list.push({'op': operation, 'arg': arg});
}

function help() {
    console.log(`SDKBAR v 0.0.1

Usage: 
sdkbar --list                                         List all installed plugins
sdkbar [--variable KEY=VALUE] --install <url or path> Install new plugin
sdkbar --remove <plugin name>                         Uninstall the installed plugin
sdkbar --update <plugin name>                         Update the plugin
sdkbar --updateall                                    Update all installed plugins
sdkbar --help                                         This page
`);
}

while(true) {
    try {
        proj = JSON.parse(fs.readFileSync(project_root+'/.cocos-project.json', 'utf8'));
        break;
    } catch (err) {
        if(project_root.length >= 2) 
            project_root = path.resolve(project_root+'/../');
        else
            break;
    }
}
if(proj == null) {
    error('Cocos project not found!');
    help();
    process.exit(1);
}

try {
    conf = JSON.parse(fs.readFileSync(project_root+'/.sdkbar.json', 'utf8'));
} catch (err) {
    conf = {};
}

function saveConf() {
    var fname = path.join(project_root,'.sdkbar.json');
    fs.writeFileSync(fname, JSON.stringify(conf, null, 4));
    debug('Config saved:', fname);
}

function compareVersions(v1, v2) {
    var vv1 = v1.split('.');
    var vv2 = v2.split('.');
    var ind = 0;
    while(true) {
        if(ind >= vv1.length && ind < vv2.length) {
            return 1;
        } else if(ind < vv1.length && ind >= vv2.length) {
            return -1;
        } else if(ind >= vv1.length && ind >= vv2.length) {
            return 0;
        } else {
            var i1 = parseInt(vv1[ind]);
            var i2 = parseInt(vv2[ind]);
            if(i1 > i2) {
                return -1;
            } else if(i1 < i2) {
                return 1;
            } else {
                ind += 1;
            }
        }
    }
}

/*******************
 *
 *  File utilities
 *
 *******************/

function extension(fname) {
    return fname.slice((fname.lastIndexOf(".") - 1 >>> 0) + 2);
}

var mkdirSync = function (dirpath) {
    try {
        fs.mkdirSync(dirpath);
    } catch(e) {
        if ( e.code != 'EEXIST' ) throw e;
    }
}

var mkdirpSync = function (dirpath) {
    var absolute = false;
    if(dirpath.lastIndexOf(path.sep, 0) === 0)
        absolute = true;
    var parts = dirpath.split(path.sep);
    for( var i = 1; i <= parts.length; i++ ) {
        var pp = path.join.apply(null, parts.slice(0, i));
        if(absolute)
            pp = path.sep + pp;
        mkdirSync( pp );
    }
}

function copyFileSync( source, target ) {
    var targetFile = target;
    //if target is a directory a new file with the same name will be created
    if ( fs.existsSync( target ) ) {
        if ( fs.lstatSync( target ).isDirectory() ) {
            targetFile = path.join( target, path.basename( source ) );
        }
    }
    debug('Copy file', source, target);
    if(fs.existsSync(targetFile))
        warning('File exist', targetFile);
    fs.writeFileSync(targetFile, fs.readFileSync(source));
    if(targetFile.startsWith(project_root)) {
        targetFile = targetFile.substring(project_root.length);
        var separator = "" + path.sep;
        if(targetFile.startsWith(separator)) {
            targetFile = targetFile.substring(separator.length);
        }
    }
    return targetFile;
}

function copyPathSync(source, target) {
    var result = []
    if ( !fs.lstatSync( source ).isDirectory() ) {
        result.push(copyFileSync(source, target));
    } else {
        target = path.join(target, path.basename(source));
        debug('Copy dir', source, target);
        mkdirpSync(target);
        var files = fs.readdirSync(source);
        for(file of files) {
            var ss = path.join(source,file)
            var stats = fs.lstatSync(ss);
            if (stats.isDirectory()) {
                result = result.concat(copyPathSync(ss, target));
            } else {
                result.push(copyFileSync(ss, target));
            }
        }
    }
    return result;
}

/*
function lookup(dirpath, dir, process_patch, process_file, iterateLevel) {
    iterateLevel = iterateLevel || 0;
    var files = fs.readdirSync(dirpath+dir);
    for(file of files) {
        var fname = path.join(dir,file);
        var stats = fs.lstatSync(dirpath+fname);
        if(path.extname(file) == '.patch' && process_patch) {
            process_patch(fname);
        } else if (stats.isDirectory()) {
            lookup(dirpath, fname, process_patch, process_file, iterateLevel + 1);
        } else if (process_file) {
            process_file(fname);
        }
    }
}
*/

function removeEmptyDirs(dir) {
    while (true) {
        try {
            fs.rmdirSync(dir);
            dir = path.dirname(dir);
        } catch (err) {
            return;
        }
    }
}

function removeRecursively(dir) {
    if( fs.existsSync(dir) ) {
        if(fs.lstatSync(dir).isDirectory()) {
            fs.readdirSync(dir).forEach(function(file,index){
                var curPath = path.join(dir, file);
                if(fs.lstatSync(curPath).isDirectory()) { // recurse
                    removeRecursively(curPath);
                } else { // delete file
                    fs.unlinkSync(curPath);
                }
            });
            fs.rmdirSync(dir);
        } else {
            fs.unlinkSync(dir);
        }
    }
}

/*******************
 *
 *  Utilities for remote sources (HTTP Git and so on)
 *
 *******************/


function download(uri, filename) {
    var protocol = url.parse(uri).protocol.slice(0, -1);
    var deferred = Q.defer();
    var onError = function (e) {
        fs.unlinkSync(filename);
        deferred.reject(e);
    }
    require(protocol).get(uri, function(response) {
        if (response.statusCode >= 200 && response.statusCode < 300) {
            var fileStream = fs.createWriteStream(filename);
            fileStream.on('error', onError);
            fileStream.on('close', deferred.resolve);
            response.pipe(fileStream);
        } else if (response.headers.location) {
            deferred.resolve(download(response.headers.location, filename));
        } else {
            deferred.reject(new Error(response.statusCode + ' ' + response.statusMessage));
        }
    }).on('error', onError);
    return deferred.promise;
};

/*******************
 *
 *  XML utilities
 *
 *******************/

function xml_append(fname, parent, tag, key, xml) {
    var data = fs.readFileSync(fname).toString();
    var etree = et.parse(data);
    // check if tag already exist
    var xpath = parent+'/'+tag;
    if(key !== null && typeof key !== 'undefined') 
        xpath = xpath + '[@'+key+']';
    var existed = etree.find(xpath);
    if(existed !== null && typeof existed !== 'undefined') {
        warning('Tag already exist:', et.tostring(existed, {'xml_declaration': false, 'indent': true}));
    } else {
        var parent = etree.find(parent);
        var node = et.parse(xml);
        parent.append(node._root);
        //console.log(et.tostring(parent, {'xml_declaration': false, 'indent': true}));
        debug('Append XML tag:', et.tostring(node._root, {'xml_declaration': false, 'indent': true}));
    }
    var xml = etree.write({'xml_declaration': true, 'indent': true, 'encoding': 'UTF-8'});
    fs.writeFileSync(fname, xml);
    return xpath;
}

function xml_remove(fname, parent, xpath) {
    var data = fs.readFileSync(fname).toString();
    var etree = et.parse(data);
    var parent = etree.find(parent);
    var nodes = etree.findall(xpath);
    if(nodes.length > 0) {
        for(key in nodes) {
            var node = nodes[key];
            var ind = parent.getchildren().indexOf(node);
            if(ind >= 0)
                parent.delItem(ind);
            else
                warning('Xml element not found:', xpath);
        }
    } else {
        warning('Xml elements not found:', xpath);
    }
    var xml = etree.write({'xml_declaration': true, 'indent': true, 'encoding': 'UTF-8'});
    fs.writeFileSync(fname, xml);
}

/*******************
 *
 *  Sdkbar functions
 *
 *******************/

function list() {
    console.log('Installed plugins:');
    Object.keys(conf).forEach(function(val, index, array) {
        console.log(val, conf[val].version);
    });
    console.log('');
}

var functioner = {
    /************** SDKBOX methods **************/
    config_merge: function(arg1, arg2) {
        warning('Warning: config_merge is unimplemented yet!');
    },
    copy_files: function(files, from, to) {
        debug('Copy files', files, from, to);
        for(key in files) {
            var src = path.join(from,files[key]);
            var dst = path.join(to,path.basename(files[key]));
            var dst_dir = path.dirname(dst);
            try {
                var copied = copyPathSync(src, to);
                install_log('copy', copied);
            } catch (err) {
                error('Failed copy', src, 'to', dst);
                error(err);
            }
        }
    },
    apply_patch: function(arg1, arg2, arg3) {
        warning('Warning: apply_patch is unimplemented yet!');
    },
    xcode_add_frameworks: function(frameworks) {
        warning('Warning: xcode_add_frameworks is unimplemented yet!');
    },
    xcode_add_sources: function() {
        warning('Warning: xcode_add_sources is unimplemented yet!');
    },
    android_copy_jars: function() {
        warning('Warning: android_copy_jars is unimplemented yet!');
    },
    android_copy_libs: function() {
        warning('Warning: android_copy_libs is unimplemented yet!');
    },
    android_add_sources: function() {
        warning('Warning: android_add_sources unimplemented yet!');
    },
    android_set_permissions: function() {
        warning('Warning: android_set_permissions unimplemented yet!');
    },
    android_add_static_libraries: function() {
        warning('Warning: android_add_static_libraries unimplemented yet!');
    },
    android_add_calls: function() {
        warning('Warning: android_add_calls unimplemented yet!');
    },
    android_add_xml_item: function(obj) {
        var xpath = obj['path'],
            tag = obj['tag'],
            key = obj['key'],
            xml = obj['xml'];
        var file = path.join(project_root, 'frameworks/runtime-src/proj.android-studio/app/AndroidManifest.xml');
        var child = xml_append(file, xpath, tag, 'android:name=\''+key+'\'', xml);
        install_log('xml', {'file': 'frameworks/runtime-src/proj.android-studio/app/AndroidManifest.xml', 'parent': xpath, 'xpath': child});
    },
    satisfies_cocos_version: function() {
        warning('Warning: satisfies_cocos_version unimplemented yet!');
        return false;
    },
    define: function(key, value) {
        warning('Warning: define unimplemented yet!');
    },
    open_documentation: function() {
        warning('Warning: open_documentation unimplemented yet!');
    },
    puts: function() {
        warning('Warning: puts unimplemented yet!');
    },
    
    /************** SdkBar methods **************/
    appDelegateInject: function(params) {
        var fname = path.join(project_root, 'frameworks/runtime-src/Classes/AppDelegate.cpp');
        var data = fs.readFileSync(fname).toString();
        var marker = params['marker'];
        var startMarker = '\n//BEGIN_'+marker+'\n';
        var endMarker = '//END_'+marker+'\n';
        if('ios' in params) {
            var include = params['ios']['include'];
            var func = params['ios']['function'];
            include = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)\n#include "'+include+'"\n#endif\n';
            func = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)\n    sc->addRegisterCallback('+func+');\n#endif\n';
            data = data.replace('\nUSING_NS_CC;', startMarker+include+endMarker+'\nUSING_NS_CC;');
            data = data.replace('\n    sc->start();', startMarker+func+endMarker+'\n    sc->start();');
        }
        if('android' in params) {
            var include = params['android']['include'];
            var func = params['android']['function'];
            include = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)\n#include "'+include+'"\n#endif\n';
            func = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)\n    sc->addRegisterCallback('+func+');\n#endif\n';
            data = data.replace('\nUSING_NS_CC;', startMarker+include+endMarker+'\nUSING_NS_CC;');
            data = data.replace('\n    sc->start();', startMarker+func+endMarker+'\n    sc->start();');
        }
        fs.writeFileSync(fname, data);
        install_log('inject', {'file': 'frameworks/runtime-src/Classes/AppDelegate.cpp', 're': '\n\\/\\/BEGIN_'+marker+'[\\s\\S]*?\\/\\/END_'+marker+'\n'});
    },
    gradleProject: function(projname, projpath) {
        var settings_file = path.join(project_root, 'frameworks/runtime-src/proj.android-studio/settings.gradle');
        var injection = `\ninclude ':${projname}'\nproject(':${projname}').projectDir = new File(settingsDir, '${projpath}')\n`;
        var data = fs.readFileSync(settings_file).toString();
        data += injection;
        fs.writeFileSync(settings_file, data);
        install_log('inject', {'file': 'frameworks/runtime-src/proj.android-studio/settings.gradle', 'str': injection});
        
        var build_file = path.join(project_root, 'frameworks/runtime-src/proj.android-studio/app/build.gradle');
        data = fs.readFileSync(build_file).toString();
        var injection2 = `    compile project(':${projname}')\n`;
        data = data.replace('dependencies {\n', 'dependencies {\n'+injection2);
        fs.writeFileSync(build_file, data);
        install_log('inject', {'file': 'frameworks/runtime-src/proj.android-studio/app/build.gradle', 'str': injection2});
    },
    androidJni: function(files) {
        var injection = '';
        for(key in files) {
            injection = injection + files[key] + ' \\\n';
        }
        var fname = path.join(project_root, 'frameworks/runtime-src/proj.android-studio/app/jni/Android.mk');
        var data = fs.readFileSync(fname).toString();
        data = data.replace('../../../Classes/AppDelegate.cpp \\\n', '../../../Classes/AppDelegate.cpp \\\n'+injection);
        fs.writeFileSync(fname, data);
        install_log('inject', {'file': 'frameworks/runtime-src/proj.android-studio/app/jni/Android.mk', 'str': injection});
    },
    add_xml_item: function(file, obj) {
        var xpath = obj['path'],
            tag = obj['tag'],
            key = obj['key'],
            xml = obj['xml'];
        debug('Add xml item', file, obj);
        var child = xml_append(file, xpath, tag, 'name=\''+key+'\'', xml);
        if(file.startsWith(project_root)) {
            file = file.substring(project_root.length);
            var separator = "" + path.sep;
            if(file.startsWith(separator)) {
                file = file.substring(separator.length);
            }
        }
        install_log('xml', {'file': file, 'parent': xpath, 'xpath': child});
    },
};

function script_install(plugin_path, plugin, origin, script) {
    var prev = conf[plugin.name];
    if(typeof prev != 'undefined' && prev != null) {
        error('Plugin', plugin.name, 'already installed (version ', plugin.version+')');
        error('Remove it first');
        process.exit(1);
    }
    conf[plugin.name] = {
        'name': plugin.name,
        'version': plugin.version,
        'origin': origin,
        'variables': variables
    };

    var default_scope = {
        'print': console.log,
        'True': true,
        'False': false,
        'COCOS_PROJECT_TYPE': 'js',
        'COCOS_2DX_VERSION': '3',
        'SDKBOX_PACKAGE_NAME': plugin.name,
        'PLUGIN_PATH': plugin_path,
        'COCOS_RESOURCES_DIR': project_root+'/res/',
        'COCOS_CLASSES_DIR': project_root+'/frameworks/runtime-src/Classes/',
        'ANDROID_ACTIVITY_NAME': 'AppActivity',
        'ANDROID_MK_USES_WILDCARDS': false,
        'ANDROID_ACTIVITY_PATH': project_root+'/frameworks/runtime-src/proj.android-studio/app/src/org/cocos2dx/javascript/',
        'ANDROID_COCOS_SRC_DIR': project_root+'/frameworks/cocos2d-x/cocos/platform/android/java/src/org/cocos2dx/lib/',
        'ANDROID_COCOS_PACKAGE_ROOT': project_root+'/frameworks/cocos2d-x/cocos/platform/android/java/',
        'ANDROID_STUDIO_PROJECT_DIR': project_root+'/frameworks/runtime-src/proj.android-studio/',
        'ANDROID_PROJECT_DIR': project_root+'/frameworks/runtime-src/proj.android/',
        'IOS_PROJECT_DIR': project_root+'/frameworks/runtime-src/proj.ios_mac/',
        'sdkbar': functioner,
        'sdkbox': functioner
    }
    var operators = {
        'IF': function(cond, block1, block2) {
            debug('if', cond);
            var res = this.do_command(cond);
            if(res === true) {
                this.do_block(block1);
            } else if(typeof block2 !== 'undefined' && block2 !== null) {
                this.do_block(block2);
            }
        },
        'AND': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 && arg2;
        },
        'OR': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            debug('or', arg1, arg2);
            return arg1 || arg2;
        },
        'EQ': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 === arg2;
        },
        'NE': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 !== arg2;
        },
        'ADD': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 + arg2;
        },
        'SUB': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 - arg2;
        },
        'MUL': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 * arg2;
        },
        'DIV': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 / arg2;
        },
        'ASSIGN': function(arg1, arg2) {
            arg2 = this.do_command(arg2);
            debug(arg1, '=', arg2);
            default_scope[arg1] = arg2;
            return arg1;
        },
        'variable': function(arg1) {
            arg1 = this.do_command(arg1);
            var value = this.resolve_name_in_scope(arg1, variables);
            if(value == null) {
                error('Variable required:', arg1);
                error('Use parameter: --variable '+arg1+'=VALUE');
                process.exit(1);
            }
            return value;
        }
    }

    var str_re1 = /^\'([^\']*)\'$/;
    var str_re2 = /^\"([^\"]*)\"$/;
    var str_re3 = /^\'\'\'([^\']+)\'\'\'$/;
    var int_re = /[0-9]+/;
    var sub_token = /^([^\.]+)\./;
    var yy = {
        result: [],
        indent: [],
        scope: default_scope,
        resolve_name_in_scope: function(n, scope) {
            var prototype=Object.getPrototypeOf(scope);
            if(prototype != null && prototype[n] != null) {
                return prototype[n].bind(scope);
            } else if(n in scope) {
                return scope[n];
            } else if(sub_token.test(n)) {
                var match = n.match(sub_token);
                var tt = match[1];
                var vv = this.resolve_name_in_scope(tt, scope);
                if(vv != null) {
                    // generic object
                    var st2 = n.substring(tt.length+1);
                    return this.resolve_name_in_scope(st2, vv);
                }
            }
            return null;
        },
        resolve_name: function(n) {
            //debug('Resolve', n, typeof n);
            if(n instanceof Array) {
                // resolve array elements
                var result = [];
                for(k in n) {
                    result.push(this.resolve_name(n[k]));
                }
                return result;
            } else if(str_re3.test(n)) {
                // multiline string
                var match = n.match(str_re3);
                return match[1];
            } else if(str_re1.test(n)) {
                // string
                var match = n.match(str_re1);
                return match[1];
            } else if(str_re2.test(n)) {
                // string
                var match = n.match(str_re2);
                return match[1];
            } else if(int_re.test(n)) {
                // integer
                return parseInt(n);
            } else if(n !== null && typeof n === 'object') {
                // object (dictionary)
                var result = {};
                for(k in n) {
                    result[k] = this.resolve_name(n[k]);
                }
                return result;
            } else {
                var res = this.resolve_name_in_scope(n, this.scope);
                if(res == null) {
                    error('variable is undefined', n);
                    return n;
                } else {
                    return res;
                }
            }
        },
        ast: function(ast) {
            yy.result = ast;
        },
        do_block: function(block) {
            var result = null;
            for(key in block) {
                var command = block[key];
                result = this.do_command(command);
            }
            return result;
        },
        do_command: function(command) {
            if(command instanceof Array) {
                // function with args
                var cmd = command.shift();
                if(cmd.startsWith('"') || cmd.startsWith("'")) {
                    // constant string detected, so process as a regular array
                    command.unshift(cmd);
                    return this.resolve_name(command);
                }
                var args = command;
                var need_resolve = false;
                var fn = this.resolve_name_in_scope(cmd, operators);
                if(fn == null) {
                    fn = this.resolve_name(cmd);
                    need_resolve = true;
                }
                if(typeof fn === "function" || Object.prototype.toString.call(fn) == '[object Function]') {
                    if(need_resolve) {
                        var processed_args = []
                        for(key in args) {
                            processed_args.push(this.do_command(args[key]));
                        }
                        args = processed_args;
                    }
                    //debug('Function', cmd, args);
                    var result = fn.apply(this, args);
                    return result;
                } else {
                    error('function', fn, 'is undefined');
                    return null;
                }
            } else if(command !== null && typeof command === 'object') {
                // parse dictionary
                var processed = {};
                for(var key in command) {
                    processed[key] = this.do_command(command[key]);
                }
                return processed;
            } else {
                // variable or value
                return this.resolve_name(command);
            }
        }
    }
    package_parser.yy = yy;
    package_parser.parse(script);
    var ast = yy.result;
    debug('Get config AST:', JSON.stringify(ast));
    yy.do_block(ast);
    conf[plugin.name]['install_log'] = install_log_list;
}

function get_remote_plugin(uri, callback) {
    // remote install
    var cache = path.join(process.env.HOME, '.sdkbar/cache');
    mkdirpSync(cache);
    // clean cache directory
    fs.readdirSync(cache).forEach(function(file, index){
        removeRecursively(path.join(cache, file));
    });
    if(/\.zip$/.test(uri)) {
        // download zip archive
        debug('Download zip archive:', uri);
        var fname = path.join(cache, 'plugin.zip');
        download(uri, fname).then(function(result) {
            debug('File downloaded:', fname);
            fs.createReadStream(fname).pipe(unzip.Extract({ path: cache })).on('close', function() {
                fs.unlinkSync(fname);
                var files = fs.readdirSync(cache);
                if(files.length >= 1) {
                    var newpath = path.join(cache, files[0]);
                    callback(null, newpath);
                } else {
                    callback('Plugin content not found', null);
                }
            });
        }, function(err) {
            callback(err, null);
        });
    } else {
        // try to clone git repo
        debug('Clone git repo:', uri);
        nodegit.Clone(uri, path.join(cache, path.basename(uri)), {}).then(function (repo) {
            callback(null, repo.workdir());
        }).catch(function (err) {
            callback(err, null);
        });
    }
}

function install(installpath, origin) {
    if(/^http/.test(installpath)) {
        // remote install
        sync(function() {
            try {
                var dir = get_remote_plugin.sync(null, installpath);
                debug('Ready to install downloaded plugin:', dir);
                install(dir, installpath);
            } catch(err) {
                error(err);
                process.exit(1);
            }
        });
    } else {
        // local install
        var plugin = null;
        var install_script = null;
        var orgn = origin || installpath;
        try {
            if(fs.existsSync(installpath+'/package.json') && fs.existsSync(installpath+'/sdkbar.package')) {
                plugin = JSON.parse(fs.readFileSync(installpath+'/package.json', 'utf8'));
                install_script = fs.readFileSync(installpath+'/sdkbar.package', 'utf8');
                var prev = conf[plugin.name];
                if(typeof prev != 'undefined' && prev != null) {
                    if(compareVersions(prev.version, plugin.version) > 0) {
                        // try to update
                        debug('Update', prev.name, 'from version', prev.version, 'to', plugin.version);
                        remove(prev.name);
                    } else {
                        warning('Skip already installed plugin:', plugin.name, plugin.version);
                        return;
                    }
                }
                console.log('Installing', plugin.name, 'version', plugin.version, 'from', installpath);
                script_install(installpath, plugin, orgn, install_script);
            } else {
                install_script = fs.readFileSync(installpath+'/sdkbox.package', 'utf8');
                console.log('Installing SDKBOX plugin from', installpath);
                script_install(installpath, {'name': 'generic-sdkbox-plugin'}, orgn, install_script);
            }
        } catch (err) {
            error(err.stack);
            if(err["code"] === "ENOENT") {
                // no such file
                error(err);
                process.exit(1);
            } else {
                if(typeof err['message'] !== 'undefined')
                    error(err['message'])
                else {
                    error(err);
                }
                process.exit(1);
            }
        }
        saveConf();
    }
}

function remove(name) {
    var cc = conf[name];
    if(typeof cc == 'undefined' || cc == null) {
        console.error('Plugin', name, 'not found!');
        process.exit(1);
    }
    var origin = cc.origin;
    var log = cc['install_log'];
    if(typeof log != 'undefined' && log != null) {
        for(key in log) {
            var op = log[key];
            if(op['op'] === 'copy') {
                // undo copy file
                var args = op['arg'];
                for(args_key in args) {
                    var arg = args[args_key];
                    if(!arg.startsWith(path.sep))
                        arg = path.join(project_root, arg);
                    if(fs.existsSync(arg)) {
                        fs.unlinkSync(arg);
                    } else {
                        warning('Warning: file not found', arg);
                    }
                    removeEmptyDirs(path.dirname(arg));
                }
            } else if(op['op'] === 'xml') {
                // remove xml node by xpath
                var arg = op['arg'];
                var file = arg['file'];
                var parent = arg['parent'];
                var xpath = arg['xpath'];
                if(!file.startsWith(path.sep))
                    file = path.join(project_root, file);
                xml_remove(file, parent, xpath);
            } else if(op['op'] === 'inject') {
                // remove source file injection
                var arg = op['arg'];
                var file = arg['file'];
                var fname = path.join(project_root, file);
                var data = fs.readFileSync(fname).toString();
                if('re' in arg) {
                    var re = arg['re'];
                    var pattern = new RegExp(re, 'g');
                    debug('remove inject', re, pattern);
                    data = data.replace(pattern, '');
                } else if('str' in arg) {
                    var pattern = arg['str'];
                    debug('remove inject', pattern);
                    data = data.replace(pattern, '');
                } else {
                    error('unknown inject argument', arg);
                }
                fs.writeFileSync(fname, data);
            } else {
                error('Unknown install operation:', op['op'], 'with arg:', op['arg']);
            }
        }
    }
    delete conf[name];
    saveConf();
}

function update(name) {
    var internal_update = function(pluginname) {
        var cc = conf[pluginname];
        if(typeof cc == 'undefined' || cc == null) {
            console.error('Plugin', pluginname, 'not found!');
            process.exit(1);
        }
        var origin = cc.origin;
        variables = cc.variables || {};
        if(/^http/.test(origin)) {
            install(origin);
        } else {
            debug('Skip local installed plugin', pluginname);
        }
    }

    if(typeof name === 'undefined' || name === null) {
        // update all
        for(var key in conf) {
            internal_update(key);
        }
    } else {
        internal_update(name);
    }
}

function setVariable(arg) {
    var ar = arg.split('=');
    if(ar.length == 2) {
        variables[ar[0]] = ar[1];
    } else {
        error('Invalid variable:', arg);
        process.exit(1);
    }
}

/*******************
 *
 *  Parsing command line arguments
 *
 *******************/

var args = process.argv.slice(2);
var command = null;
var argument = null;
var noCommand = true;
args.forEach(function (val, index, array) {
    if(/^--/.test(val)) {
        command = val.substring(2);
        if(command === 'help') {
            help();
            noCommand = false;
        } else if(command === 'list') {
            list();
            noCommand = false;
        } else if(command === 'updateall') {
            // update all plugins
            update();
            noCommand = false;
        } 
    } else if(command != null) {
        argument = val;
        if(command === 'install') {
            if(/^http/.test(argument)) {
                // remote origin
            } else {
                // local origin
                argument = path.resolve(argument);
            }
            install(argument);
            noCommand = false;
        } else if(command === 'remove') {
            remove(argument);
            noCommand = false;
        } else if(command === 'update') {
            // update installed plugin
            update(argument);
            noCommand = false;
        } else if(command === 'variable') {
            setVariable(argument);
        } else if(command != null) {
            error('Wrong command:', command);
            help();
            process.exit(1);
        }
    } else {
        console.error('Unknown parameter:', val);
        help();
        process.exit(1);
    }
});

if(noCommand) {
    error('No command!');
    help();
    process.exit(1);
}
