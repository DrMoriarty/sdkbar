#!/usr/bin/env node
const version = '0.0.4';

const fs = require('fs');
const et = require('elementtree');
const path = require('path');
const child_process = require('child_process');
const package_parser = require('./sdkbar_parser').parser;
const url = require('url');
const Q = require('q');
const unzip = require('unzip');
const nodegit = require('nodegit');
const sync = require('sync');
const tmp = require('tmp');
const glob = require('glob');
const xcode = require('xcode');
const targz = require('targz');
const deepmerge = require('deepmerge');
const diff = require('diff');

if (!String.prototype.startswith) {
  Object.defineProperty(String.prototype, 'startswith', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function(searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    }
  });
}

/*******************
 *
 *  Console utilities
 *
 *******************/

const Reset = "\x1b[0m";
const Bright = "\x1b[1m";
const Dim = "\x1b[2m";
const Underscore = "\x1b[4m";
const Blink = "\x1b[5m";
const Reverse = "\x1b[7m";
const Hidden = "\x1b[8m";

const FgBlack = "\x1b[30m";
const FgRed = "\x1b[31m";
const FgGreen = "\x1b[32m";
const FgYellow = "\x1b[33m";
const FgBlue = "\x1b[34m";
const FgMagenta = "\x1b[35m";
const FgCyan = "\x1b[36m";
const FgWhite = "\x1b[37m";

const BgBlack = "\x1b[40m";
const BgRed = "\x1b[41m";
const BgGreen = "\x1b[42m";
const BgYellow = "\x1b[43m";
const BgBlue = "\x1b[44m";
const BgMagenta = "\x1b[45m";
const BgCyan = "\x1b[46m";
const BgWhite = "\x1b[47m";

var logLevel = 1;

function debug(str) {
    if(logLevel > 0) return;
    var args = [Dim+arguments[0]];
    for(var key = 1; key < arguments.length; key++) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.log.apply(console, args);
}

function log(str) {
    if(logLevel > 1) return;
    var args = [Bright+arguments[0]];
    for(var key = 1; key < arguments.length; key++) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.log.apply(console, args);
}

function warning(str) {
    if(logLevel > 2) return;
    var args = [FgYellow+'Warning:'];
    for(key in arguments) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.log.apply(console, args);
}

function error() {
    if(logLevel > 3) return;
    var args = [FgRed+'Error:'];
    for(key in arguments) {
        args.push(arguments[key]);
    }
    args.push(Reset);
    console.error.apply(console, args);
}

/*******************
 *
 *  Config & Project 
 *
 *******************/

var proj = null;
var conf = null;
var sdkbox_conf = null;
var project_root = path.resolve("./");
var install_log_list = [];
var variables = {};
var xcode_project_file = null;
var clean_temp = true;
var skip_deps_errors = false

const android_project_dir = 'frameworks/runtime-src/proj.android-old';
const android_studio_project_dir = 'frameworks/runtime-src/proj.android';

function install_log(operation, arg) {
    install_log_list.push({'op': operation, 'arg': arg});
}

function help() {
    console.log(`SDKBAR v ${version}

usage: sdkbar [options] <command>

options:
 --verbose                      Show debug output
 -v|--variable KEY=VALUE        Set plugin variable
 --no-clean                     Don't clean the temp directory
 -f|--force                     Don't stop when unsatisfied dependencies

command:
 -l|--list                      List all installed plugins
 -b|--list-box                  List all available plugins in SDKBOX server
 -s|--search <word>             Search the plugins in SDKBOX server
 -i|--install <url, path, name> Install new plugin
 -r|--remove <plugin name>      Uninstall the installed plugin
 -u|--update <plugin name>      Update the plugin
 --updateall                    Update all installed plugins
 --show <plugin name>           More information about plugin
 -h|--help                      This page
`);
}

while(true) {
    try {
        proj = JSON.parse(fs.readFileSync(project_root+'/.cocos-project.json', 'utf8'));
        break;
    } catch (err) {
        if(project_root.length >= 2) 
            project_root = path.resolve(project_root+'/../');
        else
            break;
    }
}
if(proj == null) {
    error('Cocos project not found!');
    help();
    process.exit(1);
}

try {
    conf = JSON.parse(fs.readFileSync(project_root+'/.sdkbar.json', 'utf8'));
} catch (err) {
    conf = {};
}

try {
    sdkbox_conf = JSON.parse(fs.readFileSync(project_root+'/.sdkbox_packages.json', 'utf8'));
} catch (err) {
    sdkbox_conf = {};
}

function saveConf() {
    var fname = path.join(project_root,'.sdkbar.json');
    fs.writeFileSync(fname, JSON.stringify(conf, null, 4));
    debug('Config saved:', fname);
}

function compareVersions(v1, v2) {
    var vv1 = v1.split('.');
    var vv2 = v2.split('.');
    var ind = 0;
    while(true) {
        if(ind >= vv1.length && ind < vv2.length) {
            return 1;
        } else if(ind < vv1.length && ind >= vv2.length) {
            return -1;
        } else if(ind >= vv1.length && ind >= vv2.length) {
            return 0;
        } else {
            var i1 = parseInt(vv1[ind]);
            var i2 = parseInt(vv2[ind]);
            if(i1 > i2) {
                return -2;
            } else if(i1 < i2) {
                return 2;
            } else {
                ind += 1;
            }
        }
    }
}

function findCocosVersion() {
    var file = path.join(project_root, 'frameworks/cocos2d-x/cocos/cocos2d.cpp');
    var data = fs.readFileSync(file).toString();;
    var m = data.match('cocos2d-x-([0-9\.]+)');
    if(m) {
        debug('Cocos version:', m[1]);
        return m[1];
    } else {
        m = data.match('return "([0-9\.]+)"');
        if(m) {
            debug('Cocos version:', m[1]);
            return m[1];
        }
        error('Cocos version not found');
        return null;
    }
}

/*******************
 *
 *  File utilities
 *
 *******************/

function extension(fname) {
    return fname.slice((fname.lastIndexOf(".") - 1 >>> 0) + 2);
}

var mkdirSync = function (dirpath) {
    try {
        fs.mkdirSync(dirpath);
    } catch(e) {
        if ( e.code != 'EEXIST' ) throw e;
    }
}

var mkdirpSync = function (dirpath) {
    var absolute = false;
    if(dirpath.lastIndexOf(path.sep, 0) === 0)
        absolute = true;
    var parts = dirpath.split(path.sep);
    for( var i = 1; i <= parts.length; i++ ) {
        var pp = path.join.apply(null, parts.slice(0, i));
        if(absolute)
            pp = path.sep + pp;
        mkdirSync( pp );
    }
}

function copyFileSync( source, target ) {
    var targetFile = target;
    //if target is a directory a new file with the same name will be created
    if ( fs.existsSync( target ) && fs.lstatSync( target ).isDirectory() ) {
        targetFile = path.join( target, path.basename( source ) );
    }
    debug('Copy file', source, target);
    if(fs.existsSync(targetFile))
        warning('File exist', targetFile);
    fs.writeFileSync(targetFile, fs.readFileSync(source));
    if(targetFile.startsWith(project_root)) {
        targetFile = targetFile.substring(project_root.length);
        var separator = "" + path.sep;
        if(targetFile.startsWith(separator)) {
            targetFile = targetFile.substring(separator.length);
        }
    }
    return [targetFile];
}

function copySymLinkSync(source, target) {
    var link = fs.readlinkSync(source);
    if ( fs.existsSync( target ) && fs.lstatSync( target ).isDirectory() ) {
        target = path.join( target, path.basename( source ) );
    }
    if(fs.existsSync(target)) {
        warning('File exist', target);
        var stats = fs.lstatSync(target);
        if (stats.isDirectory()) {
            // we can not just unlink the directory
            // so copy the files inside it
            debug('Copy symlinked dir', source, 'to dir', target);
            var files = fs.readdirSync(source);
            var result = [];
            for(file of files) {
                var ss = path.join(source,file)
                var stats = fs.lstatSync(ss);
                if (stats.isDirectory()) {
                    result = result.concat(copyPathSync(ss, target));
                } else if(stats.isSymbolicLink()) {
                    result = result.concat(copySymLinkSync(ss, target));
                } else if(stats.isFile()) {
                    result = result.concat(copyFileSync(ss, target));
                }
            }
            return result;
        } else if(stats.isSymbolicLink()) {
            fs.unlinkSync(target);
        } else if(stats.isFile()) {
            fs.unlinkSync(target);
        }
    }
    debug('Copy symlink', source, target);
    fs.symlinkSync(link, target);
    if(target.startsWith(project_root)) {
        target = target.substring(project_root.length);
        var separator = "" + path.sep;
        if(target.startsWith(separator)) {
            target = target.substring(separator.length);
        }
    }
    return [target];
}

function copyPathSync(source, target) {
    var result = []
    if ( !fs.lstatSync( source ).isDirectory() ) {
        result = result.concat(copyFileSync(source, target));
    } else {
        target = path.join(target, path.basename(source));
        debug('Copy dir', source, target);
        mkdirpSync(target);
        var files = fs.readdirSync(source);
        for(file of files) {
            var ss = path.join(source,file)
            var stats = fs.lstatSync(ss);
            if (stats.isDirectory()) {
                result = result.concat(copyPathSync(ss, target));
            } else if(stats.isSymbolicLink()) {
                result = result.concat(copySymLinkSync(ss, target));
            } else if(stats.isFile()) {
                result = result.concat(copyFileSync(ss, target));
            }
        }
    }
    return result;
}

function removeEmptyDirs(dir) {
    while (true) {
        try {
            fs.rmdirSync(dir);
            dir = path.dirname(dir);
        } catch (err) {
            return;
        }
    }
}

function removeRecursively(dir) {
    debug('Clear dir', dir);
    if( fs.existsSync(dir) ) {
        if(fs.lstatSync(dir).isDirectory()) {
            fs.readdirSync(dir).forEach(function(file,index){
                var curPath = path.join(dir, file);
                if(fs.lstatSync(curPath).isDirectory()) { // recurse
                    removeRecursively(curPath);
                } else { // delete file
                    fs.unlinkSync(curPath);
                }
            });
            fs.rmdirSync(dir);
        } else {
            fs.unlinkSync(dir);
        }
    }
}

function findPatch(plugin_path, basename, projectType, cocos_version) {
    var src = path.join(plugin_path, basename+'.'+projectType+'.'+cocos_version+'.patch');
    if(fs.existsSync(src)) return src;
    src = path.join(plugin_path, basename+'.'+cocos_version+'.patch');
    if(fs.existsSync(src)) return src;
    // try to find the previous version patch
    src = null;
    var cver = cocos_version.split('.');
    cver[0] = parseInt(cver[0]);
    cver[1] = parseInt(cver[1]);
    while(cver[1] > 0) {
        cver[1] -= 1;
        src = path.join(plugin_path, basename+'.'+projectType+'.'+cver[0]+'.'+cver[1]+'.patch');
        if(fs.existsSync(src)) return src;
        src = path.join(plugin_path, basename+'.'+cver[0]+'.'+cver[1]+'.patch');
        if(fs.existsSync(src)) return src;
    }
    return null;
}

/*******************
 *
 *  Utilities for remote sources (HTTP Git and so on)
 *
 *******************/


function download(uri, filename) {
    var protocol = url.parse(uri).protocol.slice(0, -1);
    var deferred = Q.defer();
    var onError = function (e) {
        try {
            fs.unlinkSync(filename);
        } catch (e) {
        }
        deferred.reject(e);
    }
    require(protocol).get(uri, function(response) {
        if (response.statusCode >= 200 && response.statusCode < 300) {
            var fileStream = fs.createWriteStream(filename);
            fileStream.on('error', onError);
            fileStream.on('close', deferred.resolve);
            response.pipe(fileStream);
        } else if (response.headers.location) {
            deferred.resolve(download(response.headers.location, filename));
        } else {
            deferred.reject(new Error(response.statusCode + ' ' + response.statusMessage));
        }
    }).on('error', onError);
    return deferred.promise;
};

function sdkbox_manifest(callback) {
    var cache = path.join(process.env.HOME, '.sdkbar');
    mkdirpSync(cache);
    var manifest = path.join(cache, 'manifest.json');
    try {
        fs.unlinkSync(manifest);
    } catch(e) {
    }
    download('http://download.sdkbox.com/installer/v1/manifest.json', manifest).then(function(result) {
        try {
            var manifestContent = JSON.parse(fs.readFileSync(manifest).toString());
            callback && callback(null, manifestContent);
        } catch(e) {
            error('JSON parsing error:', manifest);
            error(e);
            callback && callback(e);
        }
    }, function(err) {
        error('Can not download manifest file!');
        callback && callback('Can not download manifest file!');
    });
}


/*******************
 *
 *  XML utilities
 *
 *******************/

function xml_append(fname, parent, tag, key, xml) {
    var data = fs.readFileSync(fname).toString();
    var etree = et.parse(data);
    // check if tag already exist
    var xpath = parent+'/'+tag;
    if(key !== null && typeof key !== 'undefined') 
        xpath = xpath + '[@'+key+']';
    var existed = etree.find(xpath);
    if(existed !== null && typeof existed !== 'undefined') {
        warning('Tag already exist:', et.tostring(existed, {'xml_declaration': false, 'indent': 8}));
    } else {
        var parent = etree.find(parent);
        var node = et.parse(xml);
        parent.append(node._root);
        //console.log(et.tostring(parent, {'xml_declaration': false, 'indent': 8}));
        debug('Append XML tag:', et.tostring(node._root, {'xml_declaration': false, 'indent': 8}));
    }
    var xml = etree.write({'xml_declaration': true, 'indent': 8, 'encoding': 'UTF-8'});
    fs.writeFileSync(fname, xml);
    return xpath;
}

function xml_remove(fname, parent, xpath) {
    var data = fs.readFileSync(fname).toString();
    var etree = et.parse(data);
    var parent = etree.find(parent);
    var nodes = etree.findall(xpath);
    if(nodes.length > 0) {
        for(key in nodes) {
            var node = nodes[key];
            var ind = parent.getchildren().indexOf(node);
            if(ind >= 0)
                parent.delItem(ind);
            else
                warning('Xml element not found:', xpath);
        }
    } else {
        warning('Xml elements not found:', xpath);
    }
    var xml = etree.write({'xml_declaration': true, 'indent': 8, 'encoding': 'UTF-8'});
    fs.writeFileSync(fname, xml);
}

/*******************
 *
 *  Xcode functions
 *
 *******************/

function xcode_add(sources, frameworks, xcodeproj) {
    myProj = xcode.project(xcodeproj);
    myProj.parseSync();
    debug('Open xcode project', xcodeproj);
    //var pluginsGroup = myProj.pbxGroupByName('Classes');
    var pluginsGroup = myProj.findPBXGroupKey({ name: 'Classes' });
    var targetId = null;
    var targetSection = myProj.pbxNativeTargetSection();
    for(key in targetSection) {
        var secName = targetSection[key].name;
        //debug('Section', key, secName, typeof secName !== 'undefined' ? secName.endsWith('mobile"') : '');
        if(typeof secName !== 'undefined' && secName && secName.endsWith('mobile"')) {
            targetId = key;
            debug('Select target', targetId, secName);
            break;
        }
    }
    //myProj.addHeaderFile('foo.h');
    for(var key in sources) {
        var src = sources[key];
        debug('Add xcode source file', src);
        myProj.addSourceFile(src, {target: targetId}, pluginsGroup);
    }
    var projdir = project_root+'/frameworks/runtime-src/proj.ios_mac/';
    for(var key in frameworks) {
        var frmw = frameworks[key];
        var opt = {target: targetId};
        if(fs.existsSync(path.join(projdir, frmw))) {
            //frmw = path.join(projdir, frmw);
            opt.customFramework = true;
        }
        debug('Add xcode framework file', frmw);
        myProj.addFramework(frmw, opt);
    }
    fs.writeFileSync(xcodeproj, myProj.writeSync());
    if(xcodeproj.startsWith(project_root)) {
        xcodeproj = xcodeproj.substring(project_root.length);
        var separator = "" + path.sep;
        if(xcodeproj.startsWith(separator)) {
            xcodeproj = xcodeproj.substring(separator.length);
        }
    }

    install_log('xcode', {'proj': xcodeproj, 'sources': sources, 'frameworks': frameworks});
}

function xcode_remove(sources, frameworks, xcodeproj) {
    myProj = xcode.project(xcodeproj);
    myProj.parseSync();
    sources = sources || {};
    frameworks = frameworks || {};
    var pluginsGroup = myProj.findPBXGroupKey({ name: 'Classes' });
    for(var key in sources) {
        var src = sources[key];
        myProj.removeSourceFile(src, {}, pluginsGroup);
    }
    for(var key in frameworks) {
        var frmw = frameworks[key];
        myProj.removeFramework(frmw);
    }
    fs.writeFileSync(xcodeproj, myProj.writeSync());
}

function xcode_add_lflags(flags, xcodeproj) {
    myProj = xcode.project(xcodeproj);
    myProj.parseSync();
    for(var flag in flags) {
        myProj.addToOtherLinkerFlags(flag);
    }
    fs.writeFileSync(xcodeproj, myProj.writeSync());
    if(xcodeproj.startsWith(project_root)) {
        xcodeproj = xcodeproj.substring(project_root.length);
        var separator = "" + path.sep;
        if(xcodeproj.startsWith(separator)) {
            xcodeproj = xcodeproj.substring(separator.length);
        }
    }

    install_log('xcode', {'proj': xcodeproj, 'lflags': flags});
}

function xcode_rm_lflags(flags, xcodeproj) {
    myProj = xcode.project(xcodeproj);
    myProj.parseSync();
    for(var flag of flags) {
        try {
            myProj.removeFromOtherLinkerFlags(flag);
        } catch (err) {
            error('Xcode rm lflags failed:', flag);
            error(err);
        }
    }
    fs.writeFileSync(xcodeproj, myProj.writeSync());
}

/*******************
 *
 *  Sdkbar functions
 *
 *******************/

function list() {
    console.log('Installed plugins:');
    Object.keys(conf).forEach(function(val, index, array) {
        console.log('%s\t%s\tfrom %s', val, conf[val].version, conf[val].origin);
    });
    console.log('\nSDKBOX installed plugins:');
    Object.keys(sdkbox_conf).forEach(function(val, index, array) {
        console.log('%s\t%s', sdkbox_conf[val].name, (sdkbox_conf[val].version.join('.')));
    });
    console.log('');
}

function list_box() {
    sync(function() {
        var manifestContent = sdkbox_manifest.sync(null);
        console.log('Available plugins:');
        var packs = manifestContent['packages']
        for(var pack in packs) {
            if(pack === 'SDKBOX') continue;
            var p = packs[pack];
            var vers = '';
            for(var v in p['versions']) {
                if(vers.length > 0) vers += ', ';
                vers += v;
            }
            console.log(pack, vers, '\t', p['description']);
        }
        console.log('');
    });
}

function search(pattern) {
    sync(function () {
        var manifestContent = sdkbox_manifest.sync(null);
        var pat = pattern.toLowerCase();
        console.log('Search results:');
        var packs = manifestContent['packages']
        for(var pack in packs) {
            if(pack === 'SDKBOX') continue;
            var found = false;
            var p = packs[pack];
            if(pack.toLowerCase().includes(pat))
                found = true;
            else if(p['display_name'].toLowerCase().includes(pat))
                found = true;
            else if(p['description'].toLowerCase().includes(pat))
                found = true;
            if(found) {
                var vers = '';
                for(var v in p['versions']) {
                    if(vers.length > 0) vers += ', ';
                    vers += v;
                }
                console.log(pack, vers, '\t', p['description']);
            }
        }        
        console.log('');
    });
}

function info(pname) {
    sync(function () {
        var prev = conf[pname];
        var installed = typeof prev !== 'undefined' && prev != null;
        var manifestContent = sdkbox_manifest.sync(null);
        var packs = manifestContent['packages']
        for(var pack in packs) {
            if(pack === pname) {
                var p = packs[pack];
                if(installed)
                    log('Installed:', pack, '(', p['display_name'], ')');
                else
                    log(pack, '(', p['display_name'], ')');
                console.log('Category:', p['category']);
                var deps = p['dependence'];
                if(typeof deps !== 'undefined' && deps != null && deps.length > 0) {
                    console.log('Depends on:');
                    for(var i of deps) {
                        console.log('\t', i);
                    }
                }
                var conflicts = p['conflict'];
                if(typeof conflicts !== 'undefined' && conflicts != null && conflicts.length > 0) {
                    console.log('Conflicts with:');
                    for(var i of conflicts) {
                        console.log('\t', i);
                    }
                }
                var vers = p['versions'];
                console.log('Versions:');
                for(var i in vers) {
                    if(installed && prev.version === i)
                        console.log('*\t', i);
                    else
                        console.log('\t', i);
                }
                return true;
            }
        }
        error('Plugin', pname, 'not found');
        process.exit(1);
    });
}

function Functioner(plugin_path, cocos_version) {
    var fn = {
        /************** SDKBOX variables **************/
        PROJ_ANDROID_STUDIO: 'android-studio',
        plugin_defines: {},
        
        /************** SDKBOX methods **************/
        config_merge: function(orig, dest) {
            if(fs.existsSync(dest)) {
                var origJson = JSON.parse(fs.readFileSync(orig));
                var destJson = JSON.parse(fs.readFileSync(dest));
                destJson = deepmerge(destJson, origJson);
                fs.writeFileSync(dest, JSON.stringify(destJson, null, 4));
            } else {
                copyPathSync(orig, dest);
            }
        },
        copy_files: function(files, from, to) {
            debug('Copy files', files, from, to);
            for(key in files) {
                var src = path.join(from,files[key]);
                var dst = path.join(to,path.basename(files[key]));
                var dst_dir = path.dirname(dst);
                try {
                    var copied = copyPathSync(src, to);
                    install_log('copy', copied);
                } catch (err) {
                    error('Failed copy', src, 'to', dst);
                    error(err);
                }
            }
        },
        apply_patch: function(dest, params) {
            var src = findPatch(plugin_path, path.basename(dest), 'js', cocos_version);
            if(src == null) {
                error('Patch not found', dest);
                process.exit(1);
            } else {
                debug('Applying patch', src);
                var patchContent = fs.readFileSync(src).toString();
                for(var key in fn.plugin_defines) {
                    var re = '\\$\\('+key+'\\)';
                    var value = fn.plugin_defines[key];
                    debug('Fix patch: replace', re, 'with', value);
                    patchContent = patchContent.replace(new RegExp(re, 'g'), value);
                }
                var structPatch = diff.parsePatch(patchContent);
                var fileContent = fs.readFileSync(dest).toString();
                fileContent = diff.applyPatch(fileContent, structPatch, {fuzzFactor: 5});
                if(fileContent === false) {
                    error('Can not apply patch to', dest);
                } else {
                    fs.writeFileSync(dest, fileContent);
                }
            }
        },
        xcode_add_frameworks: function(frameworks) {
            xcode_add({}, frameworks, xcode_project_file);
        },
        xcode_add_sources: function(sources) {
            xcode_add(sources, {}, xcode_project_file);
        },
        xcode_add_linker_flags: function(flags) {
            xcode_add_lflags(flags, xcode_project_file);
        },
        android_copy_jars: function(jars) {
            var orig = path.join(plugin_path, 'android', 'libs');
            var dest = path.join(project_root, 'frameworks/cocos2d-x/cocos/platform/android/java/libs');
            fn.copy_files(jars, orig, dest);
            dest = path.join(project_root, 'frameworks/cocos2d-x/cocos/platform/android/libcocos2dx/libs');
            fn.copy_files(jars, orig, dest);
        },
        android_copy_libs: function(libs) {
            var orig = path.join(plugin_path, 'android', 'jni');
            var dest = path.join(project_root, android_studio_project_dir, 'app/jni');
            fn.copy_files(libs, orig, dest);
        },
        android_add_sources: function(files) {
            var injection = '';
            for(key in files) {
                injection = injection + '../' + files[key] + ' \\\n';
            }
            var fname = path.join(project_root, android_studio_project_dir, 'app/jni/Android.mk');
            var data = fs.readFileSync(fname).toString();
            data = data.replace('../../../Classes/AppDelegate.cpp \\\n', '../../../Classes/AppDelegate.cpp \\\n'+injection);
            fs.writeFileSync(fname, data);
            install_log('inject', {'file': android_studio_project_dir+'/app/jni/Android.mk', 'str': injection});
        },
        android_set_permissions: function(permissions, verbatim) {
            for(perm of permissions) {
                if(perm.indexOf('.') < 0) perm = 'android.permission.'+perm;
                fn.android_add_xml_item({path: '.', tag: 'uses-permission', key:perm, xml:'<uses-permission android:name="'+perm+'"/>'});
            }
        },
        android_add_static_libraries: function(libs) {
            var injection = '';
            for(lib of libs) {
                injection = injection + '\n' + lib + ' \\';
            }
            var fname = path.join(project_root, android_studio_project_dir, 'app/jni/Android.mk');
            var data = fs.readFileSync(fname).toString();
            var anchor = data.match(/(LOCAL_WHOLE_STATIC_LIBRARIES[^\n]*)/);
            debug(anchor);
            if(anchor) {
                anchor = anchor[1];
                data = data.replace(anchor, anchor+injection);
            } else {
                injection = 'LOCAL_WHOLE_STATIC_LIBRARIES = \\' + injection + '\n';
                data = data + injection;
            }
            fs.writeFileSync(fname, data);
            install_log('inject', {'file': android_studio_project_dir+'/app/jni/Android.mk', 'str': injection});
        },
        android_add_calls: function(calls) {
            var injection = '\n';
            for(call of calls) {
                injection = injection + '$(call '+call+')\n';
            }
            var fname = path.join(project_root, android_studio_project_dir, 'app/jni/Android.mk');
            var data = fs.readFileSync(fname).toString();
            data = data+injection;
            fs.writeFileSync(fname, data);
            install_log('inject', {'file': android_studio_project_dir+'/app/jni/Android.mk', 'str': injection});
        },
        android_add_xml_item: function(obj) {
            var xpath = obj['path'],
                tag = obj['tag'],
                key = obj['key'],
                xml = obj['xml'];
            var file = path.join(project_root, android_studio_project_dir, 'app/AndroidManifest.xml');
            var child = xml_append(file, xpath, tag, 'android:name=\''+key+'\'', xml);
            install_log('xml', {'file': android_studio_project_dir+'/app/AndroidManifest.xml', 'parent': xpath, 'xpath': child});
        },
        android_set_app_platform: function(num) {
            warning('android_set_app_platform unimplemented yet!');
        },
        android_add_key_value: function(scope, key, value) {
            //warning('android_add_key_value unimplemented yet!');
        },
        android_add_element: function(parent, element, attributes, params) {
            var elKey = null;
            var xml = '<'+element+' ';
            for(var key in attributes) {
                if(key === 'name')
                    elKey = 'android:name=\''+attributes[key]+'\'';
                xml += 'android:'+key+'="'+attributes[key]+'" ';
            }
            xml += '/>';
            var file = path.join(project_root, android_studio_project_dir, 'app/AndroidManifest.xml');
            var child = xml_append(file, parent, element, elKey, xml);
            install_log('xml', {'file': android_studio_project_dir+'/app/AndroidManifest.xml', 'parent': parent, 'xpath': child});
        },
        android_set_target: function(target_sdk) {
            //warning('android_set_target not implemented yet!');
        },
        android_has_library_reference: function(libname) {
            //warning('android_has_library_reference not implemented yet!');
            var file = path.join(project_root, android_project_dir, 'project.properties');
            var content = fs.readFileSync(file).toString();
            return content.indexOf(libname) >= 0;
        },
        android_add_library_reference: function(libname) {
            //warning('android_add_library_reference not implemented yet!');
            var file = path.join(project_root, android_project_dir, 'project.properties');
            var content = fs.readFileSync(file).toString();
            var lines = content.split(/[\n\r]/);
            var number = 1;
            for(line in lines) {
                var match = line.match(/android\.library\.reference\.([\d]+)/);
                if(match != null) {
                    number = parseInt(match[1])+1;
                }
            }
            var injection = '\nandroid.library.reference.'+number+'='+libname.replace(path.join(project_root, 'frameworks'), '../..');
            content += injection;
            fs.writeFileSync(file, content);
            install_log('inject', {'file': android_project_dir+'/project.properties', 'str': injection});
        },
        android_studio_add_module: function(modname, libname) {
            //warning('android_studio_add_module not implemented yet!');
            var settings_file = path.join(project_root, android_studio_project_dir, 'settings.gradle');
            var projpath = libname.replace(path.join(project_root, 'frameworks'), '../..');
            var injection = `\ninclude ':${modname}'\nproject(':${modname}').projectDir = new File(settingsDir, '${projpath}')\n`;
            var data = fs.readFileSync(settings_file).toString();
            data += injection;
            fs.writeFileSync(settings_file, data);
            install_log('inject', {'file': android_studio_project_dir+'/settings.gradle', 'str': injection});
        },
        android_satisfies_sdk_version: function(ver) {
            //warning('android_satisfies_sdk_version not implemented yet!');
            var sdkver = '4.4.2'; // android-19 api level
            var com = compareVersions(ver, sdkver);
            return com == 0 || com == 1;
        },
        android_add_activity: function(activity, attributes) {
            
        },
        satisfies_cocos_version: function() {
            for(var key in arguments) {
                var arg = arguments[key];
                var comp = compareVersions(arg, cocos_version)
                if(comp == 0 || comp == 1) {
                    // they are equal or cocos version is longer then arg
                    debug('Satisfies', arg, cocos_version);
                    return true;
                }
            }
            return false;
        },
        satisfies_version: function(ver, obj) {
            var comp = compareVersions(ver, obj.version)
            if(comp == 0 || comp == 1) {
                debug('Satisfies', ver, obj);
                return true;
            }
            return false;
        },
        define: function(key, value) {
            //warning('define unimplemented yet!');
            fn.plugin_defines[key] = value;
        },
        open_documentation: function(url, param) {
            log('Plugin documentation:', url);
        },
        puts: function(data) {
            log.apply(this, arguments);
        },
        add_manual_step: function(text) {
            log(text);
        },
        supports: function(feature) {
            if(feature == 'android-studio')
                return true;
            else
                return false;
        },
        
        /************** SdkBar methods **************/
        appDelegateInject: function(params) {
            var fname = path.join(project_root, 'frameworks/runtime-src/Classes/AppDelegate.cpp');
            var data = fs.readFileSync(fname).toString();
            var marker = params['marker'];
            var startMarker = '\n//BEGIN_'+marker+'\n';
            var endMarker = '//END_'+marker+'\n';
            if('ios' in params) {
                var include = params['ios']['include'];
                var func = params['ios']['function'];
                include = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)\n#include "'+include+'"\n#endif\n';
                func = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)\n    sc->addRegisterCallback('+func+');\n#endif\n';
                data = data.replace('\nUSING_NS_CC;', startMarker+include+endMarker+'\nUSING_NS_CC;');
                data = data.replace('\n    sc->start();', startMarker+func+endMarker+'\n    sc->start();');
            }
            if('android' in params) {
                var include = params['android']['include'];
                var func = params['android']['function'];
                include = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)\n#include "'+include+'"\n#endif\n';
                func = '#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)\n    sc->addRegisterCallback('+func+');\n#endif\n';
                data = data.replace('\nUSING_NS_CC;', startMarker+include+endMarker+'\nUSING_NS_CC;');
                data = data.replace('\n    sc->start();', startMarker+func+endMarker+'\n    sc->start();');
            }
            fs.writeFileSync(fname, data);
            install_log('inject', {'file': 'frameworks/runtime-src/Classes/AppDelegate.cpp', 're': '\n\\/\\/BEGIN_'+marker+'[\\s\\S]*?\\/\\/END_'+marker+'\n'});
        },
        gradleProject: function(projname, projpath) {
            var settings_file = path.join(project_root, android_studio_project_dir, 'settings.gradle');
            var injection = `\ninclude ':${projname}'\nproject(':${projname}').projectDir = new File(settingsDir, '${projpath}')\n`;
            var data = fs.readFileSync(settings_file).toString();
            data += injection;
            fs.writeFileSync(settings_file, data);
            install_log('inject', {'file': android_studio_project_dir+'/settings.gradle', 'str': injection});
            
            var build_file = path.join(project_root, android_studio_project_dir, 'app/build.gradle');
            data = fs.readFileSync(build_file).toString();
            var injection2 = `    compile project(':${projname}')\n`;
            data = data.replace('dependencies {\n', 'dependencies {\n'+injection2);
            fs.writeFileSync(build_file, data);
            install_log('inject', {'file': android_studio_project_dir+'/app/build.gradle', 'str': injection2});
        },
        add_xml_item: function(file, obj) {
            var xpath = obj['path'],
                tag = obj['tag'],
                key = obj['key'],
                xml = obj['xml'];
            debug('Add xml item', file, obj);
            var child = xml_append(file, xpath, tag, 'name=\''+key+'\'', xml);
            if(file.startsWith(project_root)) {
                file = file.substring(project_root.length);
                var separator = "" + path.sep;
                if(file.startsWith(separator)) {
                    file = file.substring(separator.length);
                }
            }
            install_log('xml', {'file': file, 'parent': xpath, 'xpath': child});
        },
    };
    return fn;
}

var Modules = {
    os: {
        path: {
            join: path.join,
            exists: fs.existsSync
        },
        remove: fs.unlinkSync
    }
};

function script_install(plugin_path, plugin, origin, script) {
    var prev = conf[plugin.name];
    if(typeof prev != 'undefined' && prev != null) {
        error('Plugin', plugin.name, 'already installed (version ', plugin.version+')');
        error('Remove it first');
        process.exit(1);
    }
    conf[plugin.name] = {
        'name': plugin.name,
        'version': plugin.version,
        'origin': origin,
        'variables': variables
    };
    if(typeof plugin.deps !== 'undefined' && plugin.deps != null)
        conf[plugin.name]['dependence'] = plugin.deps;

    var cocos_version = findCocosVersion();
    var prjs = glob.sync(path.join(project_root,'frameworks/runtime-src/proj.ios_mac/*.xcodeproj'), {});
    if(typeof prjs !== 'undefined' && prjs.length > 0)
        xcode_project_file = path.join(prjs[0], 'project.pbxproj');
    var functioner = Functioner(plugin_path, cocos_version);

    var default_scope = {
        'print': console.log,
        'True': true,
        'False': false,
        'COCOS_PROJECT_TYPE': 'js',
        'COCOS_2DX_VERSION': cocos_version,
        'COCOS_ENGINE_MAKER': 'cocos2d-x',
        'CCC_ENGINE_VERSION': cocos_version,
        'SDKBOX_PACKAGE_NAME': plugin.name,
        'PLUGIN_PATH': plugin_path,
        'COCOS_RESOURCES_DIR': project_root+'/res/',
        'COCOS_CLASSES_DIR': project_root+'/frameworks/runtime-src/Classes/',
        'ANDROID_ACTIVITY_NAME': 'AppActivity',
        'ANDROID_MK_USES_WILDCARDS': false,
        'ANDROID_ACTIVITY_PATH'     : project_root+'/'+android_studio_project_dir+'/app/src/org/cocos2dx/javascript/',
        'ANDROID_STUDIO_ACTIVITY_PATH': project_root+'/'+android_studio_project_dir+'/app/src/org/cocos2dx/javascript/',
        'ANDROID_COCOS_SRC_DIR'     : project_root+'/frameworks/cocos2d-x/cocos/platform/android/java/src/org/cocos2dx/lib/',
        'ANDROID_LIBS_DIR'          : project_root+'/frameworks/cocos2d-x/cocos/platform/android/java/libs/',
        'ANDROID_COCOS_PACKAGE_ROOT': project_root+'/frameworks/cocos2d-x/cocos/platform/android/java/',
        'ANDROID_STUDIO_PROJECT_DIR': project_root+'/'+android_studio_project_dir+'/',
        'ANDROID_PROJECT_DIR'       : project_root+'/'+android_project_dir+'/',
        'ANDROID_STUDIO_LIBS_DIR'   : project_root+'/frameworks/cocos2d-x/cocos/platform/android/java/libs/',
        'IOS_PROJECT_DIR'           : project_root+'/frameworks/runtime-src/proj.ios_mac/',
        'XCODE_PROJECT_DIR': prjs[0],
        'XCODE_PROJECT': xcode_project_file,
        'sdkbar': functioner,
        'sdkbox': functioner
    }
    var operators = {
        'IF': function(cond, block1, block2) {
            debug('if', cond);
            var res = this.do_command(cond);
            if(res === true) {
                this.do_block(block1);
            } else if(typeof block2 !== 'undefined' && block2 !== null) {
                this.do_block(block2);
            }
        },
        'NOT': function(arg1) {
            arg1 = this.do_command(arg1);
            return !arg1;
        },
        'AND': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 && arg2;
        },
        'OR': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            debug('or', arg1, arg2);
            return arg1 || arg2;
        },
        'EQ': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 === arg2;
        },
        'NE': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 !== arg2;
        },
        'IN': function(arg1, arg2) {
            return arg2.indexOf(arg1) >= 0;
        },
        'ADD': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 + arg2;
        },
        'SUB': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 - arg2;
        },
        'MUL': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 * arg2;
        },
        'DIV': function(arg1, arg2) {
            arg1 = this.do_command(arg1);
            arg2 = this.do_command(arg2);
            return arg1 / arg2;
        },
        'ASSIGN': function(arg1, arg2) {
            arg2 = this.do_command(arg2);
            debug(arg1, '=', arg2);
            default_scope[arg1] = arg2;
            return arg1;
        },
        'INDEX': function(ar, ind) {
            ar = this.do_command(ar);
            if(ar instanceof Array) {
                return ar[ind];
            } else if(typeof ar === 'string') {
                var ar2 = ar.split('.');
                if(ar2.length > ind) {
                    return ar2[ind];
                }
            }
            error('Invalid index', ind, 'for', ar);
            process.exit(1);
        },
        'IMPORT': function(module) {
            var m = Modules[module];
            if(typeof m == 'undefined' || m == null) {
                warning('Module', module, 'not found!');
            } else {
                default_scope[module] = m;
            }
        },
        'variable': function(arg1) {
            arg1 = this.do_command(arg1);
            var value = this.resolve_name_in_scope(arg1, variables);
            if(value == null) {
                error('Variable required:', arg1);
                error('Use parameter: --variable '+arg1+'=VALUE');
                process.exit(1);
            }
            return value;
        }
    }

    var str_re1 = /^\'([^\']*)\'$/;
    var str_re2 = /^\"([^\"]*)\"$/;
    var str_re3 = /^\'\'\'([\s\S]+?)\'\'\'$/;
    var str_re4 = /^\"\"\"([\s\S]+?)\"\"\"$/;
    var int_re = /^[0-9]+$/;
    var sub_token = /^([^\.]+)\./;
    var yy = {
        result: [],
        indent: [],
        scope: default_scope,
        resolve_name_in_scope: function(n, scope) {
            var prototype=Object.getPrototypeOf(scope);
            if(prototype != null && prototype[n] != null) {
                return prototype[n].bind(scope);
            } else if(n in scope) {
                return scope[n];
            } else if(sub_token.test(n)) {
                var match = n.match(sub_token);
                var tt = match[1];
                var vv = this.resolve_name_in_scope(tt, scope);
                if(vv != null) {
                    // generic object
                    var st2 = n.substring(tt.length+1);
                    return this.resolve_name_in_scope(st2, vv);
                }
            }
            return null;
        },
        resolve_name: function(n) {
            //debug('Resolve', n, typeof n);
            if(n instanceof Array) {
                // resolve array elements
                var result = [];
                for(k in n) {
                    result.push(this.resolve_name(n[k]));
                }
                return result;
            } else if(str_re4.test(n)) {
                // multiline string
                var match = n.match(str_re4);
                return match[1].replace(/\\n/g, '\n');
            } else if(str_re3.test(n)) {
                // multiline string
                var match = n.match(str_re3);
                return match[1].replace(/\\n/g, '\n');
            } else if(str_re1.test(n)) {
                // string
                var match = n.match(str_re1);
                return match[1].replace(/\\n/g, '\n');
            } else if(str_re2.test(n)) {
                // string
                var match = n.match(str_re2);
                return match[1].replace(/\\n/g, '\n');
            } else if(int_re.test(n)) {
                // integer
                return parseInt(n);
            } else if(n !== null && typeof n === 'object') {
                // object (dictionary)
                var result = {};
                for(k in n) {
                    result[k] = this.resolve_name(n[k]);
                }
                return result;
            } else {
                var res = this.resolve_name_in_scope(n, this.scope);
                if(res == null) {
                    error('variable is undefined', n);
                    return n;
                } else {
                    return res;
                }
            }
        },
        ast: function(ast) {
            yy.result = ast;
        },
        do_block: function(block) {
            var result = null;
            for(key in block) {
                var command = block[key];
                result = this.do_command(command);
            }
            return result;
        },
        do_command: function(command) {
            if(command instanceof Array) {
                // function with args
                var cmd = command.shift();
                if(cmd.startsWith('"') || cmd.startsWith("'")) {
                    // constant string detected, so process as a regular array
                    command.unshift(cmd);
                    return this.resolve_name(command);
                }
                var args = command;
                var need_resolve = false;
                var fn = this.resolve_name_in_scope(cmd, operators);
                if(fn == null) {
                    fn = this.resolve_name(cmd);
                    need_resolve = true;
                }
                if(typeof fn === "function" || Object.prototype.toString.call(fn) == '[object Function]') {
                    if(need_resolve) {
                        var processed_args = []
                        for(key in args) {
                            processed_args.push(this.do_command(args[key]));
                        }
                        args = processed_args;
                    }
                    //debug('Function', cmd, args);
                    var result = fn.apply(this, args);
                    return result;
                } else {
                    error('function', fn, 'is undefined.', cmd, args);
                    return null;
                }
            } else if(command !== null && typeof command === 'object') {
                // parse dictionary
                var processed = {};
                for(var key in command) {
                    processed[key] = this.do_command(command[key]);
                }
                return processed;
            } else {
                // variable or value
                return this.resolve_name(command);
            }
        }
    }
    package_parser.yy = yy;
    package_parser.parse(script);
    var ast = yy.result;
    debug('Get config AST:', JSON.stringify(ast));
    yy.do_block(ast);
    conf[plugin.name]['install_log'] = install_log_list;
}

function get_remote_plugin(uri, callback) {
    // remote install
    var cache = path.join(process.env.HOME, '.sdkbar/cache');
    mkdirpSync(cache);
    // clean cache directory
    //fs.readdirSync(cache).forEach(function(file, index) {
    //    removeRecursively(path.join(cache, file));
    //});
    debug('Cache clean. Processing download...');
    if(/\.zip$/.test(uri) || /\.tar.gz$/.test(uri)) {
        // download archive
        var tmpobj = tmp.dirSync({template: cache+'/archive-XXXXXX'});
        cache = tmpobj.name;
        mkdirpSync(cache);
        debug('Download archive:', uri);
        var fname = path.join(cache, path.basename(uri));
        download(uri, fname).then(function(result) {
            debug('File downloaded:', fname);
            var proc = function() {
                if(clean_temp)
                    fs.unlinkSync(fname);
                var files = fs.readdirSync(cache);
                if(files.length >= 1) {
                    var newpath = path.join(cache, files[0]);
                    callback(null, newpath);
                } else {
                    callback('Plugin content not found', null);
                }
            };
            var err = function(e) {
                error(e);
            };
            if(/\.zip$/.test(fname)) {
                // process zip file
                fs.createReadStream(fname).pipe(unzip.Extract({ path: cache })).on('error', err).on('close', proc);
            } else if(/\.tar.gz$/.test(fname)) {
                // process tar.gz file
                targz.decompress({
                    src: fname,
                    dest: cache
                }, function(e){
                    if(e) err(e);
                    else proc();
                });
            } else {
                error('Archive format not supported:', fname);
                process.exit(1);
            }
        }, function(err) {
            callback(err, null);
        });
    } else {
        // try to clone git repo
        debug('Clone git repo:', uri);
        var dest = path.join(cache, path.basename(uri));
        removeRecursively(dest);
        nodegit.Clone(uri, dest, {}).then(function (repo) {
            callback(null, repo.workdir());
        }).catch(function (err) {
            callback(err, null);
        });
    }
}

function get_plugin_version(pname) {
    var prev = conf[pname];
    var prev_sdkbox = sdkbox_conf[pname];
    var prev_ver = null;
    if(typeof prev != 'undefined' && prev != null) {
        prev_ver = prev.version;
    }
    if(typeof prev_sdkbox != 'undefined' && prev_sdkbox != null) {
        prev_ver = prev_sdkbox.version.join('.');
    }
    return prev_ver;
}

function install_remote(url, origin, deps, callback ) {
    if(/^http/.test(url)) {
        // remote install
        sync(function() {
            try {
                debug('Remote install', url);
                var dir = get_remote_plugin.sync(null, url);
                debug('Ready to install downloaded plugin:', dir);
                install_local(dir, origin || url, deps);
                if(clean_temp) {
                    debug('Remove plugin temp directory', dir);
                    removeRecursively(dir);
                }
                return true;
            } catch(err) {
                error(err);
                process.exit(1);
            }
        }, callback);
    } else {
        error('Wrong URI:', url);
        callback && callback('Wrong URI');
    }
}

function install_sdkbox(pname, origin, callback) {
    sync(function() {
        var prev = conf[pname];
        var prev_sdkbox = sdkbox_conf[pname];
        var manifestContent = sdkbox_manifest.sync(null);
        var packs = manifestContent['packages'];
        var p = packs[pname];
        var prev_ver = get_plugin_version(pname);

        if(typeof p === 'undefined' || p === null) {
            if(prev_ver != null) {
                // not found plugin in manifest but plugin already installed from unknown source
                warning('Plugin', pname, prev_ver, 'already installed');
                callback && callback(null, true);
            } else {
                error('Plugin', pname, 'not found');
                if(!skip_deps_errors)
                    process.exit(1);
                else {
                    callback && callback('Plugin not found');
                }
            }
            return;
        }

        debug('Check conflicts for', pname);
        var conflicts = p['conflict'];
        if(typeof conflicts !== 'undefined' && conflicts != null) {
            for(cn of conflicts) {
                var pn = conf[cn];
                var pnsb = sdkbox_conf[cn];
                if(typeof pn != null && pn != null) {
                    error(pname, 'conflicts with', cn);
                    error(pn.name, 'installed version:', pn.version);
                    if(!skip_deps_errors)
                        process.exit(1);
                } else if(typeof pnsb != null && pn != null) {
                    error(pname, 'conflicts with', cn);
                    error(pnsb.name, 'installed version:', pnsb.version.join('.'));
                    if(!skip_deps_errors)
                        process.exit(1);
                }
            }
        }
        debug('Check dependencies for', pname);
        var deps = p['dependence'];
        if(typeof deps !== 'undefined' && deps != null) {
            for(dp of deps) {
                var dp_ver = get_plugin_version(dp);
                if(dp_ver == null) {
                    install_sdkbox.sync(null, dp, dp);
                } else {
                    debug('Do not upgrade dependency plugin', dp, 'with version', dp_ver);
                }
            }
        }
        var fname = null;
        var new_ver = null;
        debug('Find the source of', pname);
        for(var v in p['versions']) {
            if(prev_ver != null && compareVersions(prev_ver, v) <= 0) {
                // skip lower version
                continue;
            }
            var vd = p['versions'][v];
            if(vd && vd['v3']) {
                fname = 'http://download.sdkbox.com/installer/v1/' + vd['v3']['bundle'];
                new_ver = v;
            }
        }
        if(fname) {
            if(prev_ver != null) debug('Upgrade plugin from', prev_ver, 'to', new_ver);
            install_remote.sync(null, fname, pname, deps);
            callback && callback(null, true);
        } else {
            if(typeof prev_ver != null) {
                warning('Plugin', pname, 'already installed');
                callback && callback(null, true);
            } else {
                warning('Plugin', pname, 'not found');
                callback('Plugin not found');
            }
        }
    }, callback);
}

function install_local(installpath, origin, deps) {
    // local install
    var plugin = null;
    var install_script = null;
    var orgn = origin || installpath;
    deps = deps || [];
    try {
        if(fs.existsSync(path.join(installpath,'package.json')) && fs.existsSync(path.join(installpath,'sdkbar.package'))) {
            // install SDKBAR plugin
            plugin = JSON.parse(fs.readFileSync(installpath+'/package.json', 'utf8'));
            install_script = fs.readFileSync(installpath+'/sdkbar.package', 'utf8');
            var prev = conf[plugin.name];
            if(typeof prev != 'undefined' && prev != null) {
                if(compareVersions(prev.version, plugin.version) > 0) {
                    // try to update
                    log('Update', prev.name, 'from version', prev.version, 'to', plugin.version);
                    remove(prev.name);
                } else {
                    warning('Skip already installed plugin:', plugin.name, plugin.version);
                    return;
                }
            }
            var deps = [];
            var sdk_deps = plugin['sdk-dependence'];
            if(sdk_deps !== undefined) {
                for(var d in sdk_deps) {
                    var pl = conf[d];
                    if(pl !== undefined) {
                        debug('Found dependency', d);
                    } else {
                        error('Dependency', d, 'not installed');
                        if(!skip_deps_errors)
                            process.exit(1);
                    }
                }
            }
            plugin['deps'] = deps;
            console.log('Installing', plugin.name, 'version', plugin.version, 'from', installpath);
            script_install(installpath, plugin, orgn, install_script);
        } else {
            // install SDKBOX plugin
            console.log('Installing SDKBOX plugin from', installpath);
            var plugin_name = 'generic-sdkbox-plugin', plugin_version = 'unknown';
            var re = /sdkbox-([a-z-]+)_v([0-9\.]+)$/;
            var base = path.basename(installpath)
            if(re.test(base)) {
                var result = base.match(re);
                if(result != null) {
                    plugin_name = result[1];
                    plugin_version = result[2];
                    debug('Plugin:', plugin_name, 'version:', plugin_version);
                }
            }
            if(fs.existsSync(path.join(installpath,'sdkbox.package'))) {
                install_script = fs.readFileSync(path.join(installpath,'sdkbox.package'), 'utf8');
            } else if(fs.existsSync(path.join(installpath, 'plugin', 'sdkbox.package'))) {
                installpath = path.join(installpath, 'plugin') + path.sep;
                install_script = fs.readFileSync(path.join(installpath, 'sdkbox.package'), 'utf8');
            }
            if(install_script != null)
                script_install(installpath, {'name': plugin_name, 'version': plugin_version, 'deps': deps}, orgn, install_script);
            else {
                error('Plugin format not supported');
                process.exit(1);
            }
        }
    } catch (err) {
        if(err.stack)
            error(err.stack);
        else
            error(err);
        if(err["code"] === "ENOENT") {
            // no such file
            error(err);
            process.exit(1);
        } else {
            if(typeof err['message'] !== 'undefined')
                error(err['message'])
            else {
                error(err);
            }
            process.exit(1);
        }
    }
    saveConf();
}

function remove(name) {
    var cc = conf[name];
    if(typeof cc == 'undefined' || cc == null) {
        console.error('Plugin', name, 'not found!');
        process.exit(1);
    }
    for(var pl in conf) {
        if(name === pl) continue;
        var plugin = conf[pl];
        if(plugin !== undefined) {
            var deps = plugin.dependence;
            if(deps !== undefined) {
                for(var d of deps) {
                    if(d === name) {
                        debug(pl, 'depends on', d);
                        // some plugin depends on the removing one
                        error('Plugin', pl, 'depends on', name);
                        if(!skip_deps_errors)
                            process.exit(1);
                    }
                }
            }
        }
    }
    var origin = cc.origin;
    var log = cc['install_log'];
    if(typeof log != 'undefined' && log != null) {
        for(key in log) {
            var op = log[key];
            if(op['op'] === 'copy') {
                // undo copy file
                var args = op['arg'];
                for(args_key in args) {
                    var arg = args[args_key];
                    if(!arg.startsWith(path.sep))
                        arg = path.join(project_root, arg);
                    if(fs.existsSync(arg)) {
                        fs.unlinkSync(arg);
                    } else {
                        try {
                            if(fs.lstatSync(arg).isSymbolicLink())
                                fs.unlinkSync(arg);
                            else
                                warning('file not found', arg);
                        } catch (e) {
                            warning('file not found', arg);
                        }
                    }
                    removeEmptyDirs(path.dirname(arg));
                }
            } else if(op['op'] === 'xml') {
                // remove xml node by xpath
                var arg = op['arg'];
                var file = arg['file'];
                var parent = arg['parent'];
                var xpath = arg['xpath'];
                if(!file.startsWith(path.sep))
                    file = path.join(project_root, file);
                xml_remove(file, parent, xpath);
            } else if(op['op'] === 'inject') {
                // remove source file injection
                var arg = op['arg'];
                var file = arg['file'];
                var fname = path.join(project_root, file);
                var data = fs.readFileSync(fname).toString();
                if('re' in arg) {
                    var re = arg['re'];
                    var pattern = new RegExp(re, 'g');
                    debug('remove inject', re, pattern);
                    data = data.replace(pattern, '');
                } else if('str' in arg) {
                    var pattern = arg['str'];
                    debug('remove inject', pattern);
                    data = data.replace(pattern, '');
                } else {
                    error('unknown inject argument', arg);
                }
                fs.writeFileSync(fname, data);
            } else if(op['op'] === 'xcode') {
                var arg = op['arg'];
                var proj = path.join(project_root, arg['proj']);
                var sources = arg['sources'] || null;
                var frameworks = arg['frameworks'] || null;
                var lflags = arg['lflags'] || null;
                if(lflags != null)
                    xcode_rm_lflags(lflags, proj);
                if(sources != null || frameworks != null)
                    xcode_remove(sources, frameworks, proj);
            } else {
                error('Unknown install operation:', op['op'], 'with arg:', op['arg']);
            }
        }
    }
    delete conf[name];
    saveConf();
}

function update(name) {
    var internal_update = function(pluginname) {
        var cc = conf[pluginname];
        if(typeof cc == 'undefined' || cc == null) {
            console.error('Plugin', pluginname, 'not found!');
            process.exit(1);
        }
        var origin = cc.origin;
        variables = cc.variables || {};
        if(/^http/.test(origin)) {
            install(origin);
        } else {
            debug('Skip local installed plugin', pluginname);
        }
    }

    if(typeof name === 'undefined' || name === null) {
        // update all
        for(var key in conf) {
            internal_update(key);
        }
    } else {
        internal_update(name);
    }
}

function setVariable(arg) {
    var ar = arg.split('=');
    if(ar.length == 2) {
        variables[ar[0]] = ar[1];
    } else {
        error('Invalid variable:', arg);
        process.exit(1);
    }
}

/*******************
 *
 *  Parsing command line arguments
 *
 *******************/

var args = process.argv.slice(2);
var command = null;
var argument = null;
var tasks = [];
args.forEach(function (val, index, array) {
    if(/^--/.test(val)) {
        command = val.substring(2);
        if(command === 'help') {
            tasks.push(help);
        } else if(command === 'list') {
            tasks.push(list);
        } else if(command === 'list-box') {
            tasks.push(list_box);
        } else if(command === 'updateall') {
            // update all plugins
            tasks.push(update);
        } else if(command === 'verbose') {
            logLevel = 0;
        } else if(command === 'no-clean') {
            clean_temp = false;
        } else if(command === 'force') {
            skip_deps_errors = true;
        }
    } else if(/^-\w$/.test(val)) {
        command = val.substring(1);
        if(command === 'h') {
            tasks.push(help);
        } else if(command === 'l') {
            tasks.push(list);
        } else if(command === 'b') {
            tasks.push(list_box);
        } else if(command === 'f') {
            skip_deps_errors = true;
        }
    } else if(command != null) {
        argument = val;
        if(command === 'install' || command === 'i') {
            if(/^http/.test(argument)) {
                // remote origin
                tasks.push(install_remote.bind(null, argument));
            } else if(argument.includes(path.sep)) {
                // local origin
                argument = path.resolve(argument);
                tasks.push(install_local.bind(null, argument));
            } else {
                // sdkbox plugin name
                tasks.push(install_sdkbox.bind(null, argument));
            }
        } else if(command === 'remove' || command === 'r') {
            tasks.push(remove.bind(null, argument));
        } else if(command === 'update' || command === 'u') {
            // update installed plugin
            tasks.push(update.bind(null, argument));
        } else if(command === 'variable' || command === 'v') {
            setVariable(argument);
        } else if(command === 'search' || command === 's') {
            tasks.push(search.bind(null, argument));
        } else if(command === 'show') {
            tasks.push(info.bind(null, argument));
        } else if(command != null) {
            error('Wrong command:', command);
            help();
            process.exit(1);
        }
    } else {
        console.error('Unknown parameter:', val);
        help();
        process.exit(1);
    }
});

if(tasks.length > 0) {
    for(key in tasks) {
        var task = tasks[key];
        task();
    }
} else {
    error('No command!');
    help();
    process.exit(1);
}
